# üìù DEVELOPMENT LOG
*Linear session tracking - wiped and integrated into core docs periodically*

---

## Entry #001
**Focus:** Documentation restructure and consolidation
**Smooth:** Successfully identified all critical patterns and insights from 10+ documents
**Friction:** Initial concern about losing hard-earned insights - resolved by thorough review
**Insight:** Lean documentation with clear navigation is more valuable than comprehensive but scattered docs

---

## Entry #002
**Focus:** Quinn Tutorial Activity reward sequence implementation
**Smooth:** Canvas scaling system made dramatic animations seamless, existing star-bar sprite system was perfect for enhanced effects, question tracking integration worked naturally
**Friction:** React key duplication from momentum-based question filtering - solved with memoization and Set-based ID tracking
**Insight:** For complex UI sequences, always memoize derived data that feeds React render loops to prevent subtle key conflicts

---

## Entry #003
**Focus:** Star bar animation timing issues and debugging approach refinement
**Smooth:** React useEffect async/await pattern for sequential animations worked perfectly, two-column question indicator layout achieved desired compact design, canvas scaling system handled all visual elements seamlessly
**Friction:** Star bar visual delay persisted despite multiple technical approaches (entrance animations, CSS transitions, pseudo-elements vs real DOM elements) - root cause was likely React rendering pipeline timing rather than code logic
**Insight:** Sometimes accepting UI timing quirks and focusing on core functionality delivers better user experience than over-engineering solutions - clean code with predictable behavior trumps pixel-perfect timing

---

## Entry #004
**Focus:** Quinn Tutorial reward sequence timing and layout improvements
**Smooth:** New sequential approach eliminated timing conflicts - question results display quickly in horizontal layout, then star bar animates smoothly in single phase. Added pulsing "calculating progress" text with proper timing phases.
**Friction:** Previous complex interleaved animation caused React rendering pipeline delays and visual stuttering
**Insight:** For reward sequences, separate display phases work better than interleaved animations - show all results first, then animate progress bars for cleaner user experience. Simple CSS keyframe animations work better than complex React state-driven effects.

---

## Entry #014
**Focus:** Star unlocking procedure with ability card rewards and auto-equip system
**Smooth:** Toast notification integration with existing system worked seamlessly, auto-equip toggle behavior eliminated complex slot selection UI, ability store with leftmost-slot logic handled edge cases naturally, visual feedback (green backgrounds, checkmarks) made card states immediately clear
**Friction:** Initial custom notification component conflicted with established patterns, complex slot/card selection state management was unnecessarily verbose for simple toggle behavior
**Insight:** Leverage existing notification systems rather than creating new ones - consistency trumps custom solutions. Auto-equip with smart slot selection provides better UX than manual drag-and-drop for simple card management. Single-click toggle behavior feels more responsive than multi-step selection processes.

---

## Entry #013
**Focus:** Star modal UX polish - removed X button, added click-outside-to-close
**Smooth:** Eliminated close button component entirely, added onClick handler to ModalBackdrop with stopPropagation on Container to prevent event bubbling, clean modal dismissal pattern matching modern UX expectations
**Friction:** Event propagation needed careful handling to prevent accidental closes when clicking modal content
**Insight:** Click-outside-to-close feels more natural than explicit close buttons for modal interactions. Modern users expect this pattern - removing UI chrome often improves the experience.

---

## Entry #012
**Focus:** Fixed glitchy star modal animation - simplified zoom to clean fade-in
**Smooth:** Replaced complex zoomIn keyframes (scale + translate transforms) with simple fadeIn opacity animation, eliminated transform conflicts that caused top-left positioning glitch, reduced animation duration from 300ms to 200ms for snappier feel
**Friction:** Transform-based animations conflicted with flexbox centering causing visual jumps
**Insight:** Sometimes simpler animations work better than complex ones. Transform conflicts with layout systems create unpredictable behavior - pure opacity animations are more reliable for modal entrances.

---

## Entry #011
**Focus:** Bug fix - removed antiquated tooltip system causing UI obstruction
**Smooth:** Identified purple-bordered "View the night sky" tooltip in CombinedHomeScene, completely removed Tooltip component and all hover handling logic, eliminated hoveredArea state and related handlers cleanly
**Friction:** Multiple references to hover state needed systematic cleanup across clickable areas, styled component removal required careful coordination
**Insight:** Sometimes the best fix for problematic UI elements is complete removal rather than repair. Legacy tooltip systems can become more hindrance than help - modern UIs often work better with contextual actions rather than hover explanations.

---

## Entry #010
**Focus:** Ultra-compact unlock button - single line format
**Smooth:** Consolidated two-line button (star cost + action) into single line "Unlock 1SP", eliminated vertical flex layout in UnlockSection for horizontal centering, minimal padding (6px 12px) creates much smaller button footprint
**Friction:** Button layout restructure required coordinating multiple styled components, conditional rendering logic needed adjustment for inline star icon
**Insight:** Single-line buttons feel much more compact and professional than multi-line alternatives. Inline cost display ("1SP") is more scannable than separate cost lines. Sometimes the biggest UI improvements come from removing elements rather than adding them.

---

## Entry #009
**Focus:** Star modal final polish - vertical centering and compact unlock button
**Smooth:** align-items: center on main container perfectly centers both star and panel vertically, trimmed button text from "Enhance (Growth)" to just "Enhance" dramatically reduces button size, fixed height on StarSection (120px) ensures consistent centering regardless of content
**Friction:** Multiple style adjustments needed for proper centering coordination, button text logic required careful conditional updates
**Insight:** Perfect vertical centering requires both container alignment and explicit heights on flex children. Concise button text often provides better UX than verbose descriptions - users understand "Unlock" and "Enhance" immediately. Visual balance is more important than comprehensive labeling.

---

## Entry #008
**Focus:** Star modal UX refinements - nested unlock button, overflow glow effects, two-column layout
**Smooth:** Nested ExpandableAnswerContainer inside main panel creates perfect visual hierarchy, overflow: visible on all containers allows full star glow effects without truncation, two-column layout (star left, info right) provides better balance and space utilization
**Friction:** Multiple container overflow settings needed coordination, font size adjustments for nested button text required careful scaling
**Insight:** Nested interactive elements feel more integrated than separate sections. Visual overflow is crucial for immersive effects - truncated glows break the magic. Two-column layouts often provide better information density than stacked layouts for modal content.

---

## Entry #007
**Focus:** Star modal restructure to match QuinnTutorialActivity nested container pattern with minimal text
**Smooth:** ExpandableQuestionContainer + ExpandableAnswerContainer pattern creates perfect visual consistency, severely reduced text (single sentence description) improves readability, xxl font size (24px) for star name creates proper hierarchy, CanvasTypographyOverride ensures consistent scaling
**Friction:** Multiple unused styled components needed cleanup after restructure, close button positioning required adjustment for new single-column layout
**Insight:** Matching established UI patterns creates immediate familiarity - users understand interaction models faster. Less text with larger typography often communicates more effectively than verbose descriptions. Nested pixel containers provide natural visual hierarchy without custom styling.

---

## Entry #006
**Focus:** Star system UX refinement - transparent modal and separated click/unlock actions
**Smooth:** Transparent modal background relies on existing backdrop blur/darken beautifully, separated star click (opens modal) from unlock action (button only) creates clearer user intent, progression system (unlock ‚Üí growth ‚Üí mastery) works through single button with dynamic text
**Friction:** Button state management needed careful conditional logic for different progression states, unlock button visibility required proper condition updates for enhanced vs mastered states
**Insight:** Separating click actions from state changes improves UX clarity - clicking explores, buttons commit actions. Transparent modals work better when backdrop effects are already well-designed. Progressive enhancement through single button feels more intuitive than multiple click targets.

---

## Entry #005
**Focus:** Title screen asset system overhaul and debug console UX improvements
**Smooth:** Static sky/cloud layering system replaced scrolling background cleanly, 640x360 coordinate system integrated seamlessly with existing scaling, debug macro system with mock data generation worked perfectly for rapid testing
**Friction:** Title screen button scaling conflicts from legacy multipliers, debug console cramped layout made buttons unreadable, report card macro initially showed tutorial instead of direct access
**Insight:** When migrating from dynamic to static assets, always audit scaling multipliers for conflicts. Debug tools need generous spacing - developers spend significant time in these interfaces. Mock data generation with realistic variance is essential for proper UI testing.

---

## Entry #015
**Focus:** Day 2 progression system with advanced Quinn activity and Fast Learner ability integration
**Smooth:** Day progression system integrated seamlessly with existing architecture, Day2QuinnActivity component copied QuinnTutorialActivity structure perfectly, ability system auto-unlocks Fast Learner on day advancement, GameContainer day-based routing logic handled multiple activity variants cleanly, debug macro system allowed easy testing workflow
**Friction:** Initial confusion about ability store integration, needed to understand momentum-based question filtering system from original component, CombinedHomeScene bed handler was missing day progression logic (different from HomeScene), antiquated tutorial popups needed removal, hospital routing system defaulted to old dialogue instead of new Day 2 activity
**Insight:** When building progression systems, leverage existing component architecture as templates - copying and modifying proven patterns is more reliable than building from scratch. Auto-unlock systems work well when tied to natural game progression points like day transitions. Always verify which scene component is actually being used in production vs development. Antiquated UI elements accumulate quickly - regular cleanup prevents user confusion.

---

## Entry #016
**Focus:** Fixed Day 2 Quinn activity routing and removed antiquated UI elements
**Smooth:** React hook error quickly identified as invalid hook call inside event handler, End Day button removal cleaned up hospital interface, tutorial popup removal eliminated confusing user flows
**Friction:** Hook violation caused runtime error when clicking Quinn on Day 2, antiquated UI elements were scattered across multiple files requiring systematic cleanup
**Insight:** Always call React hooks at component level, never inside event handlers or conditional logic. When removing antiquated features, clean up all related code (styled components, handlers, state) to prevent orphaned references. UI elements accumulate quickly during development - regular cleanup prevents user confusion and technical debt.

---

## Entry #017
**Focus:** Day 2 Quinn narrative intro and Fast Learner momentum chain mechanic
**Smooth:** Dialogue system integration worked seamlessly with existing triggersActivity pattern, 2x momentum chain mechanic simple to implement and understand, visual chain indicator provides clear feedback when Fast Learner ability is ready to activate
**Friction:** Function signature mismatch initially caused routing to wrong activity, needed to understand dialogue ‚Üí activity transition flow
**Insight:** Clear ability mechanics work better than complex percentage bonuses - "2x momentum on chains" is immediately understandable. Visual feedback for ability states is crucial for player understanding. Always follow existing dialogue patterns when adding new conversations - consistency in data structure prevents integration issues.

---

## Entry #018
**Focus:** Fast Learner converted to active click-to-activate ability system
**Smooth:** Ability store activation state system integrated cleanly, click handlers on ability slots worked perfectly, visual feedback (glow, scale, tooltips) made activation state immediately clear, one-time activation with automatic deactivation after use created satisfying risk/reward timing
**Friction:** Function signature changes required updating multiple references, tooltip logic needed conditional states for different activation phases
**Insight:** Active abilities feel much more engaging than passive effects - players make deliberate choices about when to spend resources. Click-to-activate creates meaningful decision points and resource management. Visual state feedback on ability panels is crucial for understanding when abilities are ready, active, or unavailable.

---

## Entry #019
**Focus:** Simplified Fast Learner mechanic and moved explanation to pre-activity dialogue
**Smooth:** Dialogue restructure moved explanation to natural tutorial flow, simplified mechanic (next correct answer = 2x momentum) much clearer than chain requirements, deactivation after any answer creates clear risk/reward decision, tooltip states provide immediate feedback for activation readiness
**Friction:** Required removing previous answer tracking state, updating multiple tooltip conditions for different ability states
**Insight:** Simpler ability mechanics are more intuitive - "next correct answer = 2x momentum" is immediately clear vs complex chain requirements. Pre-activity explanations work better than post-activity - players understand mechanics before they need to use them. Risk/reward abilities (spend insight, get bonus or lose it) create engaging decision points.

---

## Entry #020
**Focus:** Comprehensive codebase cleanup - antiquated file removal and debug logging optimization
**Smooth:** Systematic batched cleanup approach worked perfectly, 31 antiquated files removed without breaking core functionality, debug logging reduced from console spam to clean readable output, settings button conversion preserved future extensibility, parallel cleanup execution was efficient
**Friction:** Some import references needed manual cleanup, backgroundSprite variable scoping required adjustment in TitleScreen, tileScale vs scale property correction needed
**Insight:** Large-scale cleanup is safest when done in systematic batches with immediate testing. Converting test functionality to placeholder (settings button) better than complete removal. Debug logging sweet spot is core gameplay events without technical noise - 80% reduction in console spam while preserving essential debugging info. Aggressive cleanup (5000+ lines removed) can dramatically improve codebase clarity without affecting user experience.

---

## Entry #021
**Focus:** Complete exclamation mark guidance system for star progression and card management flow
**Smooth:** CSS-based exclamation marks eliminated font rendering issues completely, screen band navigation system replaced individual clickboxes seamlessly, hover tooltip system in journal resolved overflow issues while maintaining clean card-focused design, periodic state checking with setInterval ensured reliable ability store synchronization
**Friction:** Initial grey square rendering from Aseprite pixel font conflicts, tutorial overlay removal required careful cleanup of guided tour state, desk exclamation disappeared when debug code removed due to useEffect dependency timing, naming conflicts between CardImage components needed resolution
**Insight:** When custom fonts cause rendering issues, pure CSS shapes are more reliable than text characters. Periodic state checking (setInterval) works better than useEffect dependencies for cross-store state synchronization. Screen bands provide better UX than precise clickboxes for navigation. Hover tooltips prevent layout overflow while preserving visual focus on primary elements. Debug-driven development with temporary visual indicators accelerates complex UI debugging.

---

## Entry #022
**Focus:** Fixed exclamation mark reappearing on unlocked shimmering star
**Smooth:** Bug identification was straightforward using codebase search and grep, exclamation mark guidance system was well-documented in Entry #021, existing desk exclamation already handled card management flow correctly
**Friction:** Initially needed to understand the complete guidance flow across star ‚Üí desk ‚Üí bed progression
**Insight:** UI guidance systems work best when each element has a single clear purpose - stars guide discovery/unlocking, desk guides card management, bed guides day progression. Overlapping guidance creates confusing user experiences.

---

## Entry #023
**Focus:** Implemented tutorial overlay system for QuinnTutorialActivity with selective highlighting
**Smooth:** Canvas scaling system made overlay positioning seamless, existing styled-components patterns provided perfect foundation, momentum/insight combo container highlighting worked flawlessly with $isHighlighted prop, tutorial trigger timing after mastery popup created natural flow
**Friction:** Finding optimal z-index layering for backdrop (1065), highlighted elements (1070), and modal (1080), coordinating tutorial state management with existing question flow without conflicts
**Insight:** Tutorial overlays work best when they pause the experience completely (blur/darken everything) while highlighting only the relevant UI elements. Timing tutorial triggers after existing animations (2000ms delay) prevents visual conflicts. Using existing component patterns (styled-components, canvas coordinates) ensures consistency. Selective highlighting with z-index manipulation is more effective than complex masking approaches.

---

## Entry #024
**Focus:** Fixed tutorial overlay positioning and z-index layering issues
**Smooth:** Moving overlay components outside Container eliminated layout interference completely, z-index hierarchy (1060 ‚Üí 1065 ‚Üí 1075 ‚Üí 1080) created perfect layering system, removing position: relative conflict fixed highlighting effects
**Friction:** Initial overlay rendering inside Container caused layout shifts, momentum/insight bars were being rendered below backdrop blur due to insufficient z-index values
**Insight:** Tutorial overlays must be rendered outside main component containers to avoid layout interference - React portals or sibling rendering patterns work better than nested rendering. Z-index layering requires careful planning: normal UI (1060) < backdrop (1065) < highlighted elements (1075) < modal (1080). Fixed positioning with proper z-index is more reliable than transform-based layering for overlay systems.

---

## Entry #025
**Focus:** Refined tutorial overlay system with improved animations, positioning, and timing
**Smooth:** Stacking context solution worked perfectly - rendering highlighted meters as siblings to overlay eliminated all interference, CSS gradient backdrop cutout provided clean meter highlighting without complex z-index battles, tutorial scaling system (--tutorial-scale) integrated seamlessly with highlighted elements, fade-in animation (0.6s opacity transition) replaced jarring pop-in effect
**Friction:** Initial attempts with backdrop-filter and z-index manipulation failed due to React stacking context limitations, meter positioning required manual adjustment from -25px to 500px right offset for optimal visibility, tutorial timing (2000ms ‚Üí 800ms) needed reduction to prevent second question interruption
**Insight:** React component hierarchy creates inescapable stacking contexts - elements inside containers cannot render above sibling overlays regardless of z-index. The solution is sibling rendering: hide original elements and render highlighted duplicates outside the container. Simple CSS approaches (opacity fade, gradient cutouts) often work better than complex filter effects. Tutorial timing should prioritize user flow over animation completion - 800ms provides sufficient popup visibility while maintaining narrative momentum.

---

## Entry #026
**Focus:** Quinn tutorial journal icon refinement - removed from Day 1, interactive journal button for Day 2
**Smooth:** Day 1 cleanup was straightforward removal of BookIconContainer components, Day 2 enhancement leveraged existing AbilityCardInterface pattern from CombinedHomeScene perfectly, createPortal rendering outside scaled container prevented layout conflicts, hover effects (1.1x scale, golden glow) provided satisfying visual feedback, linter error resolution with React.CSSProperties typing worked cleanly
**Friction:** Initial MultiEdit attempts failed due to missing useAbilityStore import in search pattern, WebKit CSS property typing required proper React.CSSProperties casting instead of 'as any' approach
**Insight:** When adding interactive elements to scaled canvas components, always render modals via createPortal outside the scaled container to prevent coordinate system conflicts. Removing UI elements is often as valuable as adding them - Day 1 journal removal creates cleaner learning focus while Day 2 interactive journal provides progression depth. Hover feedback on clickable elements should be subtle but noticeable - 1.1x scale with gentle glow effects feel responsive without being distracting.

---

## Entry #027
**Focus:** Animated title screen intro sequence with layered cloud transitions
**Smooth:** PIXI.js ticker-based animation system provided smooth 60fps rendering, staggered timing (clouds 0-1500ms, title 1200-2000ms, buttons 2200ms+) created cinematic reveal, easing functions (easeOutCubic, easeOutBack) added professional polish, clouds sliding from four directions (left/right/top/bottom) created dynamic depth effect
**Friction:** Initial animation loop restarted constantly due to improper state dependencies, clouds needed careful z-index ordering for proper layering
**Insight:** Title screen animations should feel cinematic but not delay player engagement - 2.8 second total sequence hits the sweet spot between impact and accessibility. Staggered element timing (overlap animations slightly) feels more dynamic than strictly sequential reveals. PIXI.js ticker loops work better than RAF for sprite-based animations due to built-in frame management.

---

## Entry #028
**Focus:** Kapoor walking character integration with sprite sheet animation system
**Smooth:** 32-frame sprite sheet mapping system (idle: 1-16, walk: 17-32) worked cleanly with background-position calculations, waypoint-based pathfinding created natural room traversal, decoupled sprite animation speed from movement speed allowed independent tuning, functional state updates eliminated dependency loop that caused initial "spazzing"
**Friction:** Initial useEffect dependency on kapoorPosition caused infinite restart loop - sprite updated position which triggered effect restart, y-position needed manual fine-tuning (420 ‚Üí 450 ‚Üí 467) to find optimal floor placement, sprite animation was too fast relative to translation speed
**Insight:** For character animation systems, separate movement logic from sprite frame updates - use refs for persistent state (waypoint index, frame count) and functional setState for position updates to avoid dependency loops. Sprite animation speed should be independently tunable from movement speed (SPRITE_FRAME_SPEED multiplier pattern). Character positioning in pixel art requires iterative visual adjustment - mathematical calculations alone won't account for sprite anchor points and visual weight. When debugging movement issues, check useEffect dependencies first - position-dependent effects create circular update loops.

---

## Entry #029
**Focus:** Keyboard-controlled Kapoor movement system replacing waypoint-based AI
**Smooth:** Set-based key tracking (keysPressed ref) handled simultaneous key presses cleanly, separate keyboard listener and animation loop useEffects prevented conflict, up/down arrows changing idle direction without movement worked intuitively for 2D side view, boundary checks (x: 20-600) prevented sprite from walking off screen edges
**Friction:** None - clean replacement of waypoint system with keyboard controls
**Insight:** For player-controlled characters, separate key state tracking (useRef<Set>) from animation loop - addEventListener updates the Set, animation loop reads it. This prevents React re-render storms while maintaining responsive controls. For 2D side-view games, vertical arrows should change facing direction (idle loops) rather than attempt impossible z-axis movement. Arrow key preventDefault is essential to stop page scrolling during gameplay.

---

## Entry #030
**Focus:** Fixed mysterious scrollbar issue and refined idle animation speed
**Smooth:** Systematic visual debugging with color-coded outlines (cyan/yellow/lime/magenta) and dimensional logging quickly identified the issue wasn't in body/html or main containers, z-index layer analysis revealed ParallaxContainer as culprit, idle animation speed adjustment (0.25x via IDLE_SPRITE_FRAME_SPEED = 12) created natural breathing effect
**Friction:** Initial assumptions about body overflow or JumboViewport/ScrollingContent were incorrect - scrollbar was rendering behind home-sky-combo.png which revealed it was on a lower z-index layer (ParallaxRenderer), required methodical elimination of possibilities
**Insight:** When debugging layout issues, visual clues about z-index layering are critical - "what renders above/below the problem element?" reveals which container is responsible. Color-coded outline debugging with refs allows precise container identification. For parallax systems, always set overflow: hidden on container to prevent scrolling layers from creating scrollbars. Idle animations should play significantly slower than walking animations (0.25x speed) for natural character breathing/fidget effects.

---

## Entry #031
**Focus:** Interactive tutorial sprites for movement controls - 8-frame arrow keys and interactive X key trigger
**Smooth:** 8-frame arrow keys sprite system (all up, right only, left only, up only, down only, all pushed, all up highlighted, all pushed highlighted) provides precise visual feedback for each key combination, key detection logic using pressedCount elegantly handles single vs multiple key presses, automatic 10-second timer prevents tutorial fatigue, X key proximity detection using distance calculation worked perfectly with adjusted positioning near Kapoor's start location for easy discovery, X key interaction system with press-depress-fade-message sequence created satisfying tactile feedback, state-gated interaction (only trigger when highlighted) prevents accidental activations, localized message display (XKeyMessageWrapper) positioned near interaction point provides contextual feedback instead of generic screen-top notifications
**Friction:** Initial 4-frame system was too limited - upgraded to 8 frames for per-key feedback, X key was hard to find at original position - moved closer to Kapoor's starting point, needed to add xKeyTriggered state to prevent re-showing tutorial after completion, initial message used generic WelcomeToastWrapper at screen top - created dedicated XKeyMessageWrapper for contextual positioning
**Insight:** Tutorial sprites benefit from granular frame states - showing each individual key press (right/left/up/down) is clearer than generic "depressed" states. Per-key frame logic with pressedCount check cleanly handles single vs multiple simultaneous presses. Tutorial element placement matters - proximity-based tutorials should appear near the player's natural path, not in distant corners. 10-second display windows prevent tutorial fatigue while giving enough time for experimentation. Interactive tutorial elements work best with clear state gating (proximity ‚Üí highlighted ‚Üí pressable) and satisfying multi-step feedback (depress ‚Üí fade ‚Üí message). Brief visual depression (150ms) before fade provides tactile confirmation of successful interaction. Messages should appear near their trigger points for spatial context - localized feedback is more immersive than screen-centered notifications.

---

## Entry #032
**Focus:** Bidirectional climbing mechanic with floor-based movement restrictions, boundaries, and smart freeze behavior
**Smooth:** Extended sprite sheet from 32 to 38 frames cleanly with proper background-size calculation (38 * 38px = 1444px), climbing state system with position-based trigger (x=525 with 10px tolerance) integrated seamlessly into existing movement logic, distance tracking via climbingStartY state enabled precise 300px climb measurement, automatic return to idle after completing upward climb worked flawlessly, bidirectional climbing (up/down arrows) uses same animation loop for both directions creating intuitive controls, floor-based movement system with dual-floor support (ground floor y=467, second floor calculated) prevents walking/idling mid-climb, tolerance-based floor detection (15px) allows smooth transitions when landing on floors, climbing boundaries (Math.max/Math.min) prevent climbing above second floor or below ground floor cleanly, frozen ladder state (isFrozenOnLadder flag) stops both position and frame updates in three scenarios: (1) player releases keys mid-climb, (2) topped out at ceiling while holding up, (3) bottomed out at floor while holding down - creates natural straining behavior at limits, climbing animation speed (CLIMB_SPRITE_FRAME_SPEED = 4) provided natural vertical movement feel distinct from walking
**Friction:** Climbing logic needed careful integration with existing walking/idle state machine to prevent conflicts, state reset conditions required handling for both climb completion and interruption, floor restriction logic required careful nesting to prevent blocking climb controls while restricting walk/idle, conditional logic for down arrow behavior required nearClimbPoint check to avoid conflicts with idle direction changes, frame freeze required separate flag (isFrozenOnLadder) to distinguish between active climbing and paused climbing states, boundary freeze behavior required applying isFrozenOnLadder flag to both topped-out and bottomed-out conditions
**Insight:** Position-based contextual actions (climbing at specific x coordinate) add depth to movement systems without complex UI prompts. Tolerance thresholds (10px for climb point, 15px for floors) make contextual triggers feel natural rather than requiring pixel-perfect positioning. Multi-floor movement systems work well with calculated positions (second floor = ground floor - climb distance) for consistency. State tracking for progressive actions (distance climbed) enables bounded interactions that feel complete rather than infinite. Floor-based movement restrictions create natural platforming constraints - walking disabled mid-air forces players to use climbing mechanics intentionally. Bidirectional climbing with same animation loop feels natural - animation context changes based on direction of movement. Boundary enforcement with Math.max/Math.min prevents going out of bounds while maintaining climbing state at limits. Frozen animation states require separate tracking (isFrozenOnLadder vs isClimbing) - maintaining visual state while blocking frame updates creates natural pausing. Animation freeze at boundaries (topped/bottomed out) creates visual feedback that player has reached a limit - the held frame communicates "straining" better than looping animation. Separate animation speeds for different movement modes (walk: 3, climb: 4, idle: 12) help distinguish action types through visual rhythm. Climbing mechanics work best when tightly scoped (specific position, specific distance) rather than universally available - creates special moments in exploration. Context-sensitive controls (down arrow = climb vs direction change) work when player intent is clear from position.

---

## Entry #033
**Focus:** Floor-specific movement boundaries with visual debugging and idle-at-boundary behavior
**Smooth:** Floor-specific boundary constants (FIRST_FLOOR_BOUNDS: 58-578, SECOND_FLOOR_BOUNDS: 373-545) integrated seamlessly into existing movement logic, visual debugging system with styled components (BoundaryLine, BoundaryLabel, BoundaryFloorIndicator) provided real-time feedback for coordinate tuning, color-coded indicators (green for first floor, orange for second floor) made floor distinction immediately clear, real-time position tracker (yellow label following Kapoor) enabled precise boundary adjustment, boundary detection via position comparison (newX === currentPos.x) triggered smooth transition to idle state while maintaining facing direction, ladder position updated to match second floor right boundary (545px) for logical building layout, console logging provided movement tracking during debugging phase
**Friction:** Initial boundary values needed iterative refinement through visual testing (20-600 ‚Üí 58-583 ‚Üí 58-578 for first floor, 480-600 ‚Üí 368-545 ‚Üí 373-545 for second floor), climbing past boundary required additional check (currentPos.x <= SECOND_FLOOR_BOUNDS.right) to prevent "hitting ceiling" when too far right
**Insight:** Visual debugging tools are essential for spatial coordination tuning - styled boundary lines and position trackers eliminate guesswork in pixel-perfect positioning. Floor-specific boundaries create natural platforming constraints that match building architecture. Idle-at-boundary behavior (checking if newX === currentPos.x after clamping) provides polish - characters don't continue walking animation when stuck at walls. Color-coded debugging (green/orange for different floors, yellow for position) makes complex spatial systems immediately readable. Iterative refinement through visual feedback is faster than mathematical calculations for game feel - test in-game and adjust. Debugging constants should be easy to toggle (DEBUG_BOUNDARIES flag) for clean production builds. Boundary enforcement works best when integrated directly into movement calculation rather than as separate validation step. Matching ladder position to floor boundary (both at 545px) creates logical spatial consistency.

---

## Entry #034
**Focus:** Kapoor parallax panning fix - translate character with home scene during sky view transition
**Smooth:** Mathematical offset formula `kapoorPosition.y - scrollPosition - (JUMBO_ASSET_HEIGHT - HOME_INTERNAL_HEIGHT)` applied cleanly to all home-view positioned elements (Kapoor, arrow keys sprite, X key sprite, X key message, boundary debugging elements), consistent pattern across all absolute-positioned elements inside ScrollingContent ensured synchronized movement, existing transition system (0.8s cubic-bezier) provided smooth visual effect without additional code
**Friction:** Initial debugging required understanding the coordinate system - scrollPosition ranges from -225 (home view) to 0 (sky view), elements at y=467 in 585px canvas would be off-screen without offset adjustment
**Insight:** When using parallax scrolling with ScrollingContent transform, absolutely positioned elements within the container need inverse scrollPosition offset to maintain realistic scene attachment. The formula `elementY - scrollPosition - baseOffset` creates the illusion of elements translating with the scene rather than staying fixed in canvas space. Consistent offset application across all scene elements (character, UI, debug tools) prevents visual drift and maintains spatial relationships. Understanding coordinate system transformations is crucial: ScrollingContent moves via translateY, so elements need compensating adjustment to "stick" to their scene region.

---

## Entry #035
**Focus:** Cinematic X key parallax scroll system with bidirectional slow transitions and keyboard-controlled navigation
**Smooth:** Walk speed increase (2.5 ‚Üí 4.0) and animation speed boost (frame speed 3 ‚Üí 2) created snappier character movement, dynamic transition duration system via props ($transitionDuration) on both ScrollingContent and ParallaxRenderer enabled variable-speed scrolling, 5-second slow scroll duration provided dramatic cinematic panning effect, removing parallax offset adjustments from all elements (Kapoor, sprites, messages) made them translate naturally with ScrollingContent container, X key bidirectional toggle (home ‚Üí sky ‚Üí home) with view change delayed until after transition completion kept Kapoor visible throughout scroll, movement disable check (early return when currentView === 'sky') cleanly froze Kapoor in sky view
**Friction:** Initial parallax offset formula caused Kapoor to zoom UP instead of translating DOWN - needed to remove `- scrollPosition - (JUMBO_ASSET_HEIGHT - HOME_INTERNAL_HEIGHT)` from positioning, X key message was rendering outside ScrollingContent causing glitches - moved inside container then removed entirely for cleaner UX, Kapoor disappeared after scroll completed due to `currentView === 'home'` conditional - removed wrapper to maintain visibility, navigation arrows needed complete removal (styled component + all instances), useEffect dependencies required adding currentView to track state properly
**Insight:** For parallax scroll systems where elements should move WITH the scene, position them purely relative to the scrolling container without counter-adjustments - the container's transform handles the movement. Dynamic transition durations work best when passed as props through the entire render tree (ScrollingContent + ParallaxRenderer) for synchronized timing. Delaying view state changes until after animations complete prevents premature hiding of transitioning elements. Bidirectional slow scrolling creates immersive cinematic moments - 5 seconds feels dramatic without being tedious. Movement systems should check view state at the start of animation loops for clean enable/disable behavior. Removing glitchy UI elements entirely is often better than trying to fix positioning issues - simple keyboard-only navigation can be more elegant than complex visual indicators.

---

## Entry #036
**Focus:** Primareus star modal redesign with desk X key interaction and simplified journal view
**Smooth:** Star renamed from "Polaris Nova" to "Primareus" with updated description emphasizing mastery progression, font size override fix (CanvasTypographyOverride had * selector forcing inheritance - added h1 exemption rule) allowed xxxl (32px) title to display properly, HighlightedText styled component with !important flags successfully colored and bolded "Radiation Therapy" in description, mastery display increased from sm (10px) to xl (16px) for prominence, desk X key system leverages existing proximity detection pattern from sky X key (show when near, hide when away), deskXKeyEnabled state tracks whether star has been viewed to gate desk interaction, x key priority system (desk ‚Üí sky ‚Üí return) ensures correct interaction based on context, AbilityCardInterface stripped down to minimal journal view (removed all card slots, equipment grid, tooltips, exclamation indicators) leaving only journal background and close instruction
**Friction:** Multiple CSS overrides fought against color styling - inline styles don't support !important, needed dedicated styled component instead, CanvasTypographyOverride * selector was too aggressive and flattened all font sizes including title, desk X key needed two-layer state (deskXKeyVisible for proximity, deskXKeyEnabled for star-viewed gate) to prevent showing before star clicked
**Insight:** When text styling fights multiple layers of CSS inheritance, create a dedicated styled component with !important flags rather than fighting with inline styles. Generic wildcard selectors (* in styled components) require exemption rules for special cases (h1 for titles). Proximity-based interactions work best with dual state: one for eligibility (has player unlocked this feature?) and one for visibility (is player near enough?). X key interaction priority should be explicit and documented - most specific context wins (desk before sky before return). Stripping complex interfaces down to minimal views improves focus - empty journal with just background and title is cleaner than cluttered card management. Position values for interactive elements benefit from iteration - started at x=65, moved to x=200, settled at x=400 for optimal desk placement.

---

## Entry #037
**Focus:** Star and telescope sprite system overhaul with keyboard-driven sky view navigation
**Smooth:** New 19-frame star sprite sheet (14x14 pixels) integrated cleanly with highlighted frames (11-13) used by default for sparkle animation, telescope sprite (640x585, 2 frames) highlights synchronously with X key in home view and independently in sky view based on navigation state, arrow key navigation (up/down) in sky view moves highlight between star and telescope creating intuitive target selection, X key interaction system checks skyHighlight state to either open star modal or scroll to home, modal close via X key eliminates need for click-outside handler providing cleaner keyboard-only workflow, frame mapping updated throughout (sparkle: 11-13, unlocking: 14-16, states: 17-19 for highlighted versions), telescope rendering outside ScrollingContent allows proper parallax movement without transform conflicts, ref-based state tracking (currentViewRef, skyHighlightRef) allows animation interval to read current values without recreating interval on every state change
**Friction:** Initial frame calculations incorrect (48px ‚Üí 56px per frame at 4x scale for 14px source), starHovered state removal required cleanup of unused handlers, StarDetailModal color references needed updating (colors.accent ‚Üí colors.starPoints/highlight, colors.success ‚Üí colors.active), ExpandableQuestionContainer variant prop not valid and needed removal, telescope z-index too low (2 ‚Üí 100) to render above home-sky-combo parallax layer, star sparkle animation needed separation of base cycle (0-2) from frame mapping (2-4 or 11-13) to prevent fighting between interval and highlight state changes
**Insight:** Keyboard-driven navigation systems benefit from explicit state tracking (skyHighlight: 'star' | 'telescope') rather than inferring from multiple flags. Sprite sheet transitions work smoothly when frame numbering conventions are maintained (highlighted versions mirror base versions with +9 offset). Modal interactions should support consistent input methods - if X key opens modal, X key should close it. Telescope sprites rendered as siblings to scrolling content move naturally with parallax without requiring position adjustments. Highlighted elements by default (vs opt-in highlighting) creates clearer visual feedback for available interactions. Priority-based X key handling (modal close ‚Üí desk ‚Üí sky scroll ‚Üí star/telescope action) prevents ambiguous interactions across different contexts. Animation intervals accessing reactive state should use refs to avoid closure staleness - interval reads currentViewRef.current instead of creating dependencies that recreate the interval. Mutually exclusive highlights (only star OR telescope) require animation logic aware of navigation state - base animation cycle (0-2) maps to appropriate frames based on shouldHighlight flag computed from current view and selection.

---

## Entry #038
**Focus:** Telescope integration into parallax layer system for cleaner architecture
**Smooth:** Extended Layer component in ParallaxRenderer to support sprite sheets via $frame and $frameCount props, telescope-sheet added to layers array alongside sky/stars/moon/clouds with frameCount: 2, background-size and background-position calculations automatically handle frame navigation (1280x585 sprite sheet = 640x585 √ó 2 frames), telescopeFrame prop passed from CombinedHomeScene ‚Üí ParallaxRenderer ‚Üí telescope layer creating clean data flow, removed manual TelescopeSprite styled component eliminating duplicate positioning logic, all 640x585 layers now stack automatically without manual positioning, parallaxFactor of 1.0 keeps telescope fixed in screen position during scroll (moves 1:1 with scroll), z-index 15 ensures telescope renders above home-sky-combo (z-index 12) and all clouds
**Friction:** Initial parallaxFactor of 0.2 caused telescope to float away during scroll - fixed with 1.0 for exact scroll synchronization, initial z-index too low (4) caused telescope to render behind home scene - increased to 15 for proper layering
**Insight:** Parallax layer systems benefit from generic sprite sheet support rather than special-casing individual layers. Frame-based rendering (background-position offset) works perfectly for multi-frame sprite sheets when integrated into existing layer infrastructure. Passing layer-specific props through renderer (telescopeFrame) maintains clean separation while enabling dynamic behavior. Manual positioning of full-screen sprites (640x585) should be avoided when parallax system already handles stacking - integrate into layer system instead. When multiple elements share dimensions and rendering characteristics (sky, clouds, telescope all 640x585), they belong in the same rendering system. ParallaxFactor determines scroll synchronization: 1.0 = stays fixed (moves with scroll), 0.2 = slow background movement, values between create depth illusion. Z-index layering in parallax systems requires coordination with other rendering contexts (ScrollingContent z-index 12) to prevent overlap issues.

---

## Entry #039
**Focus:** Star modal frame conversion to eliminate highlight in enlarged view
**Smooth:** getNonHighlightedFrame helper function cleanly converts highlighted frames (11-19) to non-highlighted equivalents (2-10) by subtracting 9, applied at initialization and in frame update useEffect, handleUnlock progression uses non-highlighted frames (8-10) for modal display while notifying parent with highlighted frames (17-19) for sky view consistency, dual frame system (modal: 2-10, parent: 11-19) maintains proper visual separation between contexts
**Friction:** None - straightforward frame offset calculation worked on first attempt
**Insight:** Modal displays should use context-appropriate visuals even when synced with external state - the enlarged star doesn't need highlight because it's already the focus of attention. Frame conversion at component boundaries (parent highlighted ‚Üí modal non-highlighted) maintains consistent visual language while adapting to different contexts. When parent and child use different frame ranges from same sprite sheet, helper functions for conversion prevent magic numbers scattered through code. Success message conditional checks (currentFrame === 10 vs 19) must match the context's frame range.

---

## Entry #040
**Focus:** Animated journal sprite sheet with opening animation and interactive button states
**Smooth:** 8-frame horizontal sprite sheet (600x361 per frame) integrated cleanly into AbilityCardInterface modal, opening animation (frames 0-4) plays automatically on component mount with 100ms frame timing landing on static frame 4, button interaction system uses frames 5-7 for depressed/highlighted/both states with smooth hover and press detection, background-position calculation (frame * -600px) works perfectly for sprite sheet navigation, isAnimating state cleanly separates opening sequence from interactive mode preventing button interference during animation, container dimensions matched frame size exactly (600x361) preventing adjacent frame bleeding, overflow: hidden clips any edge cases
**Friction:** Initial container size mismatch (640x360 vs 600x361 frames) caused frame remnants - fixed by matching dimensions exactly
**Insight:** Modal opening animations create polished first impressions - 400ms total animation (4 frames √ó 100ms) feels cinematic without delaying interaction. Button state frames work best when structured as variants of the base frame (frame 4 static ‚Üí frames 5-7 variations) rather than separate visuals. Separating animation mode from interactive mode with boolean flag prevents state conflicts - buttons only appear after animation completes. Positioned ButtonArea divs with mouse event handlers provide precise interaction zones for sprite-embedded UI elements without requiring complex image maps. Stop propagation on button events prevents accidental modal close during button interaction. Sprite sheet container dimensions MUST match frame dimensions exactly to prevent adjacent frame bleeding - even small mismatches create visual artifacts.

---

## Entry #041
**Focus:** Enhanced journal UX with highlighted default button and X key interaction, plus star X key sprite for first-time guidance
**Smooth:** Journal button now defaults to highlighted state (frame 6) creating clear call-to-action, X key press triggers depression (frame 7) with 150ms visual feedback before closing, removed hover state logic simplifying interaction model to just pressed/unpressed, star X key sprite positioned next to star (340px, 75px) when in sky view with star highlighted, priority-based X key handling (Priority 3) intercepts star X key press before fallback handlers, starXKeyTriggered state prevents repeated triggers, visibility conditional (currentView === 'sky' && skyHighlight === 'star' && starXKeyVisible) ensures context-appropriate display
**Friction:** Initial priority ordering confusion with multiple X key handlers - resolved by documenting clear priority hierarchy (modal close ‚Üí desk ‚Üí star ‚Üí home scroll ‚Üí telescope), duplicate "Priority 4" comments needed renaming, extra closing brace from previous conditional restructure
**Insight:** Default-highlighted UI elements create immediate visual focus - users know where to interact without exploration. Keyboard shortcuts should mirror mouse interactions with consistent visual feedback (150ms depression before action). Priority-based input handling prevents ambiguous interactions across different game contexts - document the hierarchy explicitly in comments. X key sprites as contextual hints work best when positioned near their interaction targets (star at 320px ‚Üí X key at 340px). Triggered state flags (starXKeyTriggered) prevent duplicate executions while allowing state cleanup on context changes. Multiple X key interaction zones require careful dependency management in useEffect arrays to prevent stale closures.

---

## Entry #042
**Focus:** Comp-sheet combat intro animation with journal slide-down, cycling letter toast, and test button debug shortcut
**Smooth:** Journal slide-down animation uses CSS keyframes with cubic-bezier easing for smooth 120vh translation, comp-sheet slides up from bottom with lower z-index (999 vs 1001) creating proper layering effect, toast 9-slice container displays "So you think you know ---?" with cycling random letters (120ms interval) for dynamic effect, closing animation sequence (150ms button press ‚Üí 800ms animations ‚Üí 400ms toast delay ‚Üí 2000ms total) creates cinematic transition, test button localStorage flag ('debug_skip_to_desk') enables instant desk interaction mode, debug mode in CombinedHomeScene positions Kapoor at x=200, enables deskXKeyVisible immediately, and skips welcome screen via hasShownWelcomeRef, comp-sheet scales responsively with @media query for mobile viewports
**Friction:** Initial z-index conflicts required careful layering (overlay 1000 ‚Üí comp-sheet 999 ‚Üí journal 1001 ‚Üí toast 1500), needed to add $isClosing prop to both overlay and container for coordinated animation timing, toast visibility timing required nested setTimeout calls to sequence properly (button press ‚Üí slide animations ‚Üí toast reveal), Kapoor state management used separate direction/walking flags rather than unified state enum, linter error from non-existent setKapoorState needed correction to setKapoorDirection + setKapoorIsWalking
**Insight:** Multi-element closing animations work best with explicit state flags ($isClosing) rather than relying on onClose timing alone - prevents race conditions and allows proper cleanup. Z-index layering for overlapping animations requires planning the full stack upfront: overlay base ‚Üí background elements ‚Üí foreground elements ‚Üí floating UI. Cycling text animations with setInterval create dynamic "thinking" effects - 120ms timing feels responsive without being seizure-inducing. localStorage debug flags provide clean one-shot shortcuts for testing specific game states without persisting between sessions. When adding debug shortcuts, position characters in logical gameplay positions (desk area for desk interaction) rather than spawn points. Responsive scaling for pixel art assets (640px base with viewport-relative fallback) maintains crisp rendering across device sizes. Sequential setTimeout nesting (150 ‚Üí 800 ‚Üí 400 pattern) creates natural-feeling animation choreography where each element has its moment. Toast notifications appearing after primary animations (400ms delay) prevent visual overload while maintaining narrative flow.

---

## Entry #043
**Focus:** Comp-sheet persistent display refinements with overflow fixes, dramatic toast scaling, and HDR reveal
**Smooth:** Comp-sheet verified at correct dimensions (600x360px via sips), wrapper system with CompSheetWrapper (handles centering/scaling) + CompSheetContainer (handles slide animation) creates clean separation of concerns, overflow: hidden applied to both wrapper and container completely eliminates scrollbar issues (referencing Entry #030 and #040 patterns), comp-sheet and toast now persist after journal slide-away creating clean activity interface, toast dramatically enlarged (32px ‚Üí 36px text with xl container size) with text-shadow and glow effects for cycling letters, cycling animation lands on "HDR" after 5 seconds (42 cycles √ó 120ms) using cycle counter with hasLanded flag, journal/overlay conditionally hidden after closing ($isClosing check) leaving comp-sheet as main focus, toast positioned 250px above comp-sheet center for optimal visibility
**Friction:** Initial scrollbar appearance required consulting dev log entries #030 and #040 for overflow: hidden solution, styled-components v4 keyframe interpolation error needed css helper wrapper for conditional animations, toast size required multiple iterations to achieve "drastically bigger" effect (20px ‚Üí 32px text, 16px 32px ‚Üí 24px 48px padding), transform stacking for comp-sheet (translate + scale + translateY) initially conflicted - resolved by separating into wrapper (translate/scale) and container (translateY animation)
**Insight:** Recurring issues (scrollbars, sprite bleeding) document well in dev logs - always reference past entries when similar symptoms appear (overflow: hidden is the universal fix). Wrapper pattern for complex transforms (outer handles positioning/scaling, inner handles animation) prevents transform conflicts and creates predictable behavior. Toast dramatic sizing requires multiple visual properties working together: large font (32px+), generous padding (24px 48px), text-shadow for depth, glow effects for emphasis, and strong color contrast. Cycling animations that "land" on specific text work best with explicit counters and stop conditions rather than time-based setTimeout - provides frame-accurate control. Persistent UI after modal close requires conditional rendering of overlay/modal rather than relying on close callbacks - prevents premature cleanup. Component persistence patterns: journal disappears ‚Üí comp-sheet stays ‚Üí activity happens on comp-sheet. Always verify sprite dimensions with sips before implementing scaling systems.

---

## Entry #044
**Focus:** Comp-sheet backdrop blur and toast landing animation refinements
**Smooth:** CompSheetBackdrop component with backdrop-filter: blur(5px) matches journal overlay effect perfectly, z-index layering (998 backdrop ‚Üí 999 comp-sheet ‚Üí 1500 toast) creates clean visual hierarchy, scaleUpToast keyframe animation scales toast from 0.3 to 1.0 over 4 seconds with cubic-bezier easing for smooth landing effect, HDR landing reduced from 42 cycles (5 seconds) to 33 cycles (4 seconds) syncing perfectly with toast scale animation completion, starting opacity 0.5 prevents jarring appearance while still showing cycling letters throughout growth
**Friction:** Initial attempt to reuse InterfaceOverlay caused timing conflicts - separate CompSheetBackdrop needed for independent visibility control
**Insight:** Multi-element animation sequences benefit from precise timing alignment - toast scale animation duration matching HDR landing creates satisfying synchronized climax. Backdrop effects should be separated by context rather than reused when visibility timing differs. Starting animations from partial opacity (0.5) instead of zero creates smoother perceptual growth while maintaining visibility throughout. Transform composition in keyframes (translate + scale) allows complex positioning with animated scaling in single declaration.

---

## Entry #045
**Focus:** Interactive multi-question quiz system with sequential progression
**Smooth:** QuestionToastWrapper slides up from bottom 500ms after HDR lands creating sequential narrative flow, slideUpQuestion keyframe animation with translateY(100vh) ‚Üí translateY(0) provides smooth entrance, OptionButton components with $isSelected state handle click interactions cleanly, golden highlight background (colors.starPoints) and checkmark icon (‚úì) provide clear visual feedback for selected options, z-index 1499 positions question toast just below main toast (1500) for proper stacking, overflow: hidden applied to QuestionToastWrapper, QuestionContent, OptionsContainer, and individual OptionButtons prevents scrollbar issues from hover effects (referencing Entry #030, #040, #043 pattern), balanced text sizing (question: 34px, options: 26px, checkmark: 32px) as middle ground between readability and space efficiency, min-width: 600px on QuestionContent accommodates longer question text without wrapping issues, questions array with currentQuestionIndex state enables sequential question progression, 2-second setTimeout after option selection allows user to see their choice before advancing, dynamic option rendering with .map() supports variable-length question sets, selectedOption reset on question transition prevents UI state leakage
**Friction:** Transform composition for question positioning required calc(-50% + 100px) offset to position below main toast while maintaining centering, initial hover effects caused clipping/scrollbars due to missing overflow: hidden on nested containers, translateX/scale hover effects caused text truncation requiring removal, text sizing required iteration to find middle ground (28px/22px ‚Üí 40px/30px ‚Üí 34px/26px), longer question text needed container width increase (min-width: 600px)
**Insight:** Sequential toast animations work best with slight delays (500ms) between major transitions - prevents overwhelming the user while maintaining engagement. Interactive buttons within toast containers need explicit pointer-events control (all when visible, none when hidden) to prevent click-through issues. Selected state styling should be highly visible (background swap + checkmark) for immediate recognition. Multiple choice questions benefit from vertical stacking with generous spacing (16px gap) for touch-friendly interaction. The overflow: hidden pattern must be applied at EVERY container level (wrapper, content, options container, individual buttons) to fully prevent scrollbar issues - one missing level breaks the whole chain. Transform-based hover effects (translateX, scale) can cause text truncation in constrained containers - pure color/background transitions are more reliable when overflow clipping is required. Font sizing is a balance: too small hurts readability, too large wastes space - iterate toward middle ground (34px/26px works well for quiz questions). Sequential question systems should pause briefly (2s) after selection to let users register their choice before context switches. Dynamic question rendering with array.map() + index state is more maintainable than hardcoded question JSX. Min-width on containers prevents awkward text wrapping in longer questions while maintaining responsive centering.

---

## Entry #046
**Focus:** Results screen for quiz system with answer tracking and constellation prompt
**Smooth:** Added correctAnswer property to question data structure for validation, userAnswers state array tracks selections across multiple questions, results calculation filters correct answers using question index matching, conditional visibility (showResults state) cleanly transitions from questions to results screen, ResultsNote styled component with starPoints color and glow effect creates visual consistency with existing toast system, 300ms delay between hiding questions and showing results prevents jarring transition
**Friction:** None - straightforward state management and conditional rendering
**Insight:** Quiz systems benefit from explicit correct answer tracking rather than relying on position conventions. Results screens work best with celebratory styling (glowing text, larger fonts) to acknowledge completion. Transition delays between UI states (300ms) create smoother perceived flow than instant switches. Progress prompts ("check your constellation") guide players toward next discovery without forcing navigation.

---

## Entry #047
**Focus:** X key exit flow for quiz results with animated comp-sheet slide-down and return to home
**Smooth:** XKeyIndicator component scaled 3x with sprite sheet frames (unpressed/pressed) provides clear interaction prompt, showXKey state with 400ms delay ensures smooth appearance after results display, priority-based X key handler (results exit ‚Üí journal close) prevents conflicting interactions, isExiting state triggers slideDownCompSheet animation (0.8s cubic-bezier), backdrop opacity fades out synchronously with comp-sheet exit, 150ms visual feedback on key press before triggering animations matches existing interaction patterns, onClose callback after 800ms animation completion returns cleanly to home scene
**Friction:** None - pattern matching from CombinedHomeScene X key system worked seamlessly
**Insight:** Exit flows for multi-step activities should feel as polished as entrance flows - coordinated animations (backdrop fade, sheet slide, key press feedback) create satisfying closure. Large-scale UI elements (3x sprite scaling) work well for important action prompts. Priority-based keyboard handlers need clear documentation when multiple contexts share same key binding. Timing coordination (150ms press ‚Üí 800ms animation ‚Üí callback) creates perceived responsiveness while allowing smooth visual transitions. Cleaning up all visible state (toasts, indicators, backdrops) before calling onClose prevents orphaned UI elements.

---

## Entry #048
**Focus:** Constellation introduction cutscene with multi-star system and connection line
**Smooth:** Game store state tracking (hasCompletedFirstActivity, hasSeenConstellationCutscene) gates cutscene to play once after first desk activity completion, pre-generated random star positions using useMemo ensures consistent star placement across renders, multi-phase cutscene orchestration (stars-appearing 0-2s ‚Üí building-tension 2-5s ‚Üí boom 5-5.5s ‚Üí final-constellation 5.5-6.5s ‚Üí complete) with setTimeout cascade creates cinematic reveal, pulsation animation speed changes based on phase (200ms normal, 100ms tension) builds dramatic momentum, BoomEffectOverlay with radial gradient and scale transform creates impactful flash effect, ConnectionLine component with mathematical transform calculations (Math.sqrt for length, Math.atan2 for rotation) renders stylized line between constellation stars, multi-star navigation system updated to support 3 targets (radiation_therapy, hdr, telescope) with left/right arrows cycling between stars and up/down for quick jumps, constellation stars use frame offset logic (highlighted frame 17 ‚Üí normal frame 11 via -6 offset) for consistent visual states, cutscene only plays when shouldPlayCutscene flag is true (completed first activity AND not seen cutscene), all cutscene elements render inside scaled JumboViewport except boom overlay which needs full-screen effect
**Friction:** TypeScript skyHighlight state type needed expansion from binary 'star' | 'telescope' to include 'radiation_therapy' | 'hdr', navigation logic required conditional branching based on showFinalConstellation flag to handle both pre-cutscene and post-cutscene navigation modes, connection line math required careful center-point offsetting (+7px for 14px stars) to align properly between star centers
**Insight:** Cutscene systems benefit from explicit state tracking (hasSeenConstellationCutscene) to prevent replaying - one-time cinematics should feel special, not repetitive. Multi-phase cutscenes work best with setTimeout cascade rather than complex state machines - linear timing is easier to reason about and adjust. Pulsation animation speed as tension-building mechanic creates visceral buildup without requiring complex visual effects. Math-based styled components (ConnectionLine with transform calculations) allow dynamic positioning without hardcoded SVG paths. Navigation systems should gracefully handle both simple and complex states - conditional logic based on feature flags (showFinalConstellation) enables progressive complexity. Pre-generated randomness (useMemo with empty deps) ensures visual consistency while maintaining organic appearance. Frame offset patterns (¬±6 for highlighted variants) create maintainable sprite sheet conventions. Full-screen effects (boom overlay) must render outside scaled containers to avoid transform inheritance issues.

---

## Entry #049
**Focus:** Constellation cutscene refinements - mysterious nebula naming, localized star field, opacity oscillation
**Smooth:** Renamed Primareus to "???" with vague nebula description ("uncharted stars...study to bring clarity") creates mystery and player intrigue, PRIMAREUS_POSITION constant (x:180, y:200) moved star further left for better visual balance, polar coordinate generation (angle + distance) localizes cutscene stars in 120px radius around Primareus creating focused nebula effect, sparkle frames updated from 11-13 to 2-4 matching sprite sheet sparkle animation, opacity property added to cutsceneStars state and rendering with sine wave oscillation (0.3-1.0 range) creates organic pulsating effect, tutorial star conditional rendering (!isPlayingCutscene && !showFinalConstellation) hides original star during cutscene preventing visual conflicts, final constellation positioning uses PRIMAREUS_POSITION for radiation_therapy star with HDR offset -100px to left maintaining spatial relationship
**Friction:** Had to update cutsceneStars TypeScript type to include opacity: number, star X key position needed recalculation relative to new PRIMAREUS_POSITION (+20px right, -5px up), opacity oscillation math required sine wave calculation (Math.abs(Math.sin(opacityPhase * Math.PI))) for smooth pulsing
**Insight:** Mystery naming ("???") creates player curiosity and discovery motivation better than explicit labels. Polar coordinate generation (angle + distance from center) creates natural circular distributions around focal points. Localized star fields (120px radius) feel more intentional than random full-screen distributions. Opacity oscillation (0.3-1.0) with sine waves creates organic pulsating that feels alive rather than mechanical. Tutorial elements should conditionally hide during cutscenes to prevent visual clutter and confusion. Centralizing position constants (PRIMAREUS_POSITION) enables easy global adjustments without hunting through code. Frame ranges 2-4 (sparkle) vs 11-13 (highlighted sparkle) maintain consistent animation patterns while allowing context-appropriate visuals.

---

## Entry #050
**Focus:** Constellation cutscene polish - reduced star count, desynchronized animations, simplified boom effect, final star frames
**Smooth:** Reduced cutscene star count from 10-20 to 3-6 creates cleaner, more focused nebula effect, added frameOffset (0-3) and opacityOffset (0-2œÄ) to each star for desynchronized pulsing/fading, boom effect simplified from radial gradient pulse to simple full-screen flash (rgba(255, 215, 0, 0.6)) for cleaner visual impact, final constellation stars now use frames 5-7 for appearing animation (200ms per frame) before landing on frame 8 (HDR) and frame 10 (radiation_therapy), connection line between constellation stars removed per user request, highlighting logic updated to use +9 frame offset for highlighted versions (frame 8‚Üí17, frame 10‚Üí19)
**Friction:** TypeScript state type needed expansion to include frameOffset and opacityOffset properties, animation logic required modulo arithmetic for proper frame cycling with offsets, final constellation animation needed setInterval cleanup to prevent memory leaks
**Insight:** Fewer stars with varied animation creates more organic, less mechanical effect than many synchronized stars. Individual animation offsets (frame timing, opacity phase) make star field feel alive rather than artificial. Simple screen flash is more dramatic than complex radial gradients for climax moments. Frame-based appearing animations (5-7) provide satisfying reveal sequence before landing on final state frames. Removing connecting lines between stars maintains cleaner, more mysterious aesthetic. When animating multiple elements to final states, use intervals with proper cleanup to prevent state update leaks.

---

## Entry #051
**Focus:** Constellation cutscene simplification - single star focus, repositioning, hiding UI during animation
**Smooth:** Removed random cutscene stars (3-6 background stars) - cutscene now focuses solely on ??? star pulsing and transforming into constellation, moved all constellation stars higher in sky (y: 200‚Üí120) for better visual composition, added isPlayingCutsceneRef to track cutscene state in animation interval without recreating interval, star highlighting now disabled during cutscene (sparkle animation uses base frames 2-4 instead of highlighted 11-13), X key indicator hidden during cutscene (!isPlayingCutscene condition added to visibility), final constellation stars don't highlight during cutscene animation (only after completion), cutsceneStarOpacity state with sine wave animation (0.3-1.0) creates pulsating effect on ??? star during cutscene, exclamation indicator hidden during cutscene to eliminate yellow blip distraction, skyHighlight automatically set to 'radiation_therapy' when cutscene completes for natural navigation flow
**Friction:** Needed to create isPlayingCutsceneRef and update it in sync with isPlayingCutscene state to allow animation interval to read current cutscene state without dependencies, multiple visibility conditionals needed updates (!isPlayingCutscene added to star X key, tutorial star highlighting, and constellation star highlighting), initial implementation accidentally hid ??? star during cutscene - needed to change condition from !isPlayingCutscene && !showFinalConstellation to just !showFinalConstellation, constellation stars initially rendered outside ScrollingContent causing parallax mismatch - moved inside for consistent behavior, opacity animation required separate state (cutsceneStarOpacity) applied inline to star sprite style
**Insight:** Focusing cutscene on single transforming element (??? star) creates cleaner, more dramatic narrative than busy star field. Removing distracting elements (random stars, highlights, X key prompts) during cutscene keeps player attention on the core transformation. Using refs for frequently-changing state in animation intervals prevents interval recreation while maintaining access to current values. Cutscene UI should be minimal - hide all interactive elements until the reveal completes. Higher star positioning (lower y values) in sky view creates better visual hierarchy and sense of depth. All stars in the same visual layer must be rendered in the same container (ScrollingContent) to maintain consistent parallax behavior during view transitions. Opacity animations during cutscenes create organic pulsing effect - apply inline styles with state-driven opacity values. Automatically setting navigation highlight after cutscene guides player attention to newly revealed content.

---

## Entry #052
**Focus:** Star exclamation removal and constellation star detail modals
**Smooth:** Removed all exclamation mark indicators from stars entirely (cleaned up ExclamationIndicator component usage for stars), added activeStarId state to track which star modal is open ('star' | 'radiation_therapy' | 'hdr'), updated X key handler to open modals for all three constellation stars when highlighted, StarDetailModal now accepts starId prop and displays different content based on star type, created starDataMap with unique name/description/topic for each star, constellation stars (HDR and Radiation Therapy) are display-only with no unlock buttons - show "Visit your desk to study this topic" message instead of mastery counter, starFrame calculation automatically uses correct frame for each star (8 for HDR, 10 for radiation_therapy)
**Friction:** X key handler needed conditional logic to check skyHighlight against all three star types, starFrame prop needed ternary expression to calculate correct frame based on activeStarId, isConstellationStar flag required to conditionally render different UI sections
**Insight:** Exclamation marks on stars create visual clutter and reduce mysterious aesthetic - clean star sprites are more appealing. Multi-star modal systems work well with activeId pattern to track which variant is displayed. Constellation stars revealed during cutscene work best as informational displays rather than unlockable progression systems - keeps focus on ??? star as main progression mechanism. Display-only modals should clearly communicate their purpose (e.g., "Visit desk to study") rather than showing disabled unlock buttons. Frame calculations can be handled inline with ternary expressions when logic is simple (starId-based frame selection).

---

## Entry #053
**Focus:** Title screen debug state grid with animated transitions and sprite sheet icons
**Smooth:** 3x3 grid overlay system activated by "Test Activity" button provides clean debug navigation, animated transitions (600ms ease-out cubic) smoothly moves title up, fades out Play/Test buttons, and reveals debug grid, PIXI ticker isolation with introAnimationComplete flag prevents ticker from fighting custom animations, sprite sheet system for debug icons (56x53px √ó 2 frames horizontal) uses background-position offset pattern for frame selection, empty grid boxes clickable to dismiss overlay creates intuitive close interaction, debug state handlers set localStorage flags ('debug_skip_to_desk', 'debug_skip_to_cutscene') for instant context loading, dual state tracking (introComplete + introCompleteRef) allows event handlers to read current state without closure staleness, What's New button fades out during debug mode preventing overlapping UI
**Friction:** Initial PIXI ticker continued running after intro causing buttons to reset to visible/alpha=1 fighting fade-out animation - fixed by adding introAnimationComplete flag to stop ticker, button interaction required eventMode: 'static' instead of deprecated interactive: true property for PIXI v8, dependency array on transition effect initially included isLoaded/introComplete causing unwanted re-runs on intro completion - removed to only trigger on showDebugGrid changes, Close button initially added then removed in favor of click-to-close on empty boxes, grid positioning iterated from 61% to 64% for optimal spacing below raised title
**Insight:** PIXI ticker loops must be explicitly stopped when their animation phase completes - continuing tickers will fight against external state changes. Event handlers defined in useEffect closures need ref-based state access (introCompleteRef.current) to avoid capturing stale values from initial render. Sprite sheet patterns work well for debug UI - background-position offsets (frame √ó -width) provide clean frame selection without separate image files. Animation dependency arrays should only include state that directly triggers the animation - auxiliary flags like isLoaded cause unwanted animation runs. Empty interactive areas (grid boxes) work better than explicit close buttons for dismissing overlays - feels more natural and reduces UI chrome. Debug grid positioning should account for title movement - centering between raised title and screen bottom (64%) creates balanced composition. Fade-out animations on multiple elements (buttons + What's New) require coordinated state checks to hide everything simultaneously. Debug state systems benefit from localStorage flags that gate specific behaviors rather than complex state initialization - one flag per debug scenario keeps logic simple.

---

## Entry #054
**Focus:** Fixed debug option 2 (pre-cutscene) state initialization missing from CombinedHomeScene
**Smooth:** Added new useEffect handler in CombinedHomeScene to read debug_skip_to_cutscene localStorage flag, positioned Kapoor near telescope (x=480) in ready position, setHasCompletedFirstActivity(true) enables cutscene trigger, X key pre-enabled with highlighted frame (3) for immediate interaction, pattern matches existing debug_skip_to_desk handler for consistency
**Friction:** Initial bug report revealed flag was being set in TitleScreen but never read in CombinedHomeScene - debug system was incomplete
**Insight:** Debug state systems require both flag-setting (in launcher/menu) and flag-reading (in target scene) to work correctly - always implement the full round-trip. When adding new debug states, follow existing patterns for consistency (position setup, tutorial element hiding, flag cleanup). Pre-cutscene state should enable the trigger condition (hasCompletedFirstActivity) without marking content as seen (hasSeenConstellationCutscene) to allow actual playthrough of the cutscene.

---

## Entry #055
**Focus:** Constellation cutscene polish - remove ??? star highlighting during scroll-up and add cinematic letterbox bars
**Smooth:** Conditional skyHighlight setting (only when NOT playing cutscene) prevents ??? from highlighting during dramatic scroll-up, CinematicLetterbox styled component with $position prop ('top'|'bottom') creates reusable bars, translateY transforms (¬±100% off-screen ‚Üí 0% on-screen) create smooth slide-in effect, 1.5s cubic-bezier easing provides dramatic yet smooth animation, z-index 9998 positions bars above all game content but below boom flash, isPlayingCutscene visibility flag automatically shows/hides bars with cutscene lifecycle, 80px bar height provides substantial cinematic framing without excessive coverage
**Friction:** Initial implementation set skyHighlight('star') immediately on X key press causing highlight during scroll - needed conditional logic based on shouldPlayCutscene flag, nested conditional logic in setTimeout required careful placement to set highlight AFTER cutscene completes for navigation
**Insight:** Cutscene presentation benefits from removing gameplay UI hints (star highlighting) during dramatic sequences - maintains mystery and focus. Cinematic letterbox bars create immediate "this is special" perception - simple black bars with slide animation are more effective than complex effects. Transform-based animations (translateY ¬±100%) work better than height animations for letterboxes - consistent visual weight throughout transition. Timing cutscene UI elements to appear/disappear with cutscene state (isPlayingCutscene) creates synchronized presentation. Post-cutscene cleanup should restore navigation hints (highlight star) for intuitive player guidance. Letterbox height (80px) should be substantial enough for cinematic effect but not so large it obscures critical content.

---

## Entry #056
**Focus:** Cutscene refinements - fix persistent star highlighting during scroll, double letterbox bars, logarithmic easing, and z-index layering
**Smooth:** Added isCutsceneScrolling state flag to track scroll transition phase separately from actual cutscene, isCutsceneScrollingRef integration allows animation interval to read current scroll state without recreating intervals, shouldHighlight logic now checks both isCutscenePlaying AND isCutsceneScrolling preventing highlight during entire transition sequence, letterbox bars doubled from 80px to 160px for more dramatic cinematic framing, cubic-bezier(0.2, 1, 0.4, 1) easing creates logarithmic curve - fast start with exponential slowdown at end mimicking natural deceleration, letterbox visibility condition (isCutsceneScrolling || isPlayingCutscene) ensures bars appear during both scroll and cutscene phases, z-index reordering (boom: 9997, letterbox: 9998) positions flash effect behind black bars maintaining clean framing
**Friction:** Initial conditional skyHighlight logic wasn't enough - star animation runs continuously in interval and checks view state, needed separate scrolling flag tracked via ref for interval access, star highlighting logic required understanding of view-based conditions (in home view, always highlight unless cutscene-related), nested setTimeout timing required careful flag management (set isCutsceneScrolling ‚Üí scroll ‚Üí clear flag when cutscene starts)
**Insight:** Complex animation sequences benefit from granular state tracking - separate flags for "scrolling to cutscene" vs "in cutscene" provide precise control over UI elements throughout transitions. Animation intervals that check reactive state must use refs to avoid recreating intervals - pattern: state + stateRef + useEffect to sync them. Logarithmic easing (fast start, slow end) feels more natural and dramatic than linear or symmetric curves for cinematic effects - cubic-bezier(0.2, 1, 0.4, 1) is the sweet spot. Letterbox bars at 160px (vs 80px) provide substantially more cinematic framing - nearly fills vertical space on 16:9 displays creating true widescreen effect. Z-index layering for cutscene effects should prioritize structural elements (letterbox bars) above atmospheric effects (screen flash) - maintains visual consistency and framing integrity. Visibility conditions using OR logic (scrolling || playing) ensure UI elements persist through multi-phase sequences without flicker.

---

## Entry #057
**Focus:** Dramatic letterbox swelling effect and constellation expansion with 8 additional stars
**Smooth:** Letterbox bars increased to 220px height for maximum dramatic impact, transition duration extended to 7 seconds with cubic-bezier(0.15, 0.9, 0.3, 1) for ultra-slow swelling effect that keeps closing and closing before boom, constellation expanded from 2 to 10 stars scattered around Radiation Therapy center point, new stars positioned using offset calculations from PRIMAREUS_POSITION with varied distances (35-100px) creating organic cluster, frame variety (frames 6-10) assigned to different stars for visual diversity, placeholder names follow radiation oncology theme (Brachytherapy, IMRT, SBRT, Proton Beam, Gamma Knife, CyberKnife, TomoTherapy, VMAT), type system extended throughout (SkyHighlightType, StarIdType) to support all 10 constellation stars plus telescope, StarDetailModal updated with complete star data including names/descriptions/topics for each new star, frameMap pattern used consistently for star frame assignments in both animation completion and modal rendering
**Friction:** Type system expansion required updates across multiple components (CombinedHomeScene state types, StarDetailModal interface), X key handler needed array-based check for constellation stars to accommodate growing list, initial linter errors from type mismatches between modal interface and parent component
**Insight:** Dramatic cutscene effects benefit from extreme values - 7 second animation with 220px intrusion creates visceral anticipation that pays off with boom moment. Logarithmic easing with shallow initial curve (0.15, 0.9) creates that "keeps closing... and closing... and closesssss" feeling by compressing acceleration into final moments. Constellation design works well with hub-and-spoke pattern - one central star (Radiation Therapy) surrounded by related topics creates visual hierarchy and thematic clustering. When expanding type systems, use type aliases at component level (SkyHighlightType, StarIdType) rather than inline union types - enables consistent references and easier maintenance. Frame variety across constellation stars (6-10) prevents visual monotony while maintaining sprite sheet consistency. Placeholder content should follow domain naming conventions (radiation oncology terms) for conceptual coherence even before final content exists. Pattern consistency (frameMap object for all frame assignments) prevents scattered magic numbers and enables future adjustments from single source.

---

## Entry #058
**Focus:** Constellation cutscene timing refinement - letterbox delay, star frame standardization, tighter clustering
**Smooth:** Letterbox visibility changed from (isCutsceneScrolling || isPlayingCutscene) to just isPlayingCutscene creating dramatic pause between scroll completion and bars sliding in, all constellation stars standardized to frame 8 except radiation_therapy (frame 10) creating visual unity with one distinctive center star, star positions tightened significantly (100px max distance ‚Üí 65px max distance) creating cohesive cluster, simplified frame assignment logic from complex frameMap to simple ternary (radiation_therapy ? 10 : 8), HDR moved closer to center (100px left ‚Üí 60px left) maintaining constellation hierarchy
**Friction:** None - straightforward timing and positioning adjustments
**Insight:** Cutscene timing benefits from distinct phases - scroll completes (5s) ‚Üí brief pause ‚Üí letterbox begins (7s) ‚Üí boom creates rhythm rather than overlapping effects fighting for attention. Visual hierarchy in constellations works best with one distinctive center element (frame 10) surrounded by uniform supporting elements (frame 8) - draws eye to focal point while maintaining cohesive group appearance. Tighter star clustering (30-65px vs 35-100px) creates more recognizable constellation shape and stronger visual identity. Simpler conditional logic (ternary vs frameMap) improves maintainability when most values follow same pattern with one exception. Sequential animation phases (scroll ‚Üí pause ‚Üí letterbox ‚Üí cutscene ‚Üí boom) feel more controlled and impactful than simultaneous effects.

---

## Entry #059
**Focus:** Asymmetrical letterbox bars and ultra-tight constellation clustering
**Smooth:** Letterbox bars now asymmetrical with top bar at 140px (less intrusion) and bottom bar at 280px (dramatic intrusion creating 2:1 ratio), asymmetry achieved by moving height property inside conditional logic blocks while maintaining shared transition/z-index properties, star clustering tightened to maximum 50px distance (down from 65px), most stars now within 25-42px creating very compact constellation shape, HDR brought even closer (60px ‚Üí 45px left), all distance adjustments maintain organic scatter pattern while creating recognizable cluster
**Friction:** None - clean CSS refactoring and straightforward position adjustments
**Insight:** Asymmetrical letterbox bars create more dynamic framing than symmetrical - bottom-heavy composition (280px vs 140px) draws focus upward to where constellation appears while maintaining cinematic effect. 2:1 ratio feels natural rather than arbitrary. Ultra-tight star clustering (25-50px radius) transforms loose scatter into recognizable constellation shape - viewers can perceive the group as single entity rather than individual points. Maintaining slight position variance (not perfect grid) within tight bounds preserves organic constellation feeling. For cutscene framing, asymmetry creates visual interest and can guide viewer attention to specific screen regions.

---

## Entry #060
**Focus:** Constellation 3D orbital animation system around radiation therapy star
**Smooth:** Extended constellation star state to include angle, distance, scale, and opacity properties for 3D effect calculations, createStar helper function calculates initial polar coordinates (angle via Math.atan2, distance via Math.sqrt) from Cartesian offsets, orbital animation useEffect updates angles continuously at 0.008 radians per frame (~60fps via 16ms setInterval), elliptical orbit created by compressing Y-axis movement with ELLIPSE_RATIO (0.5) simulating perspective foreshortening, z-depth calculation using Math.sin(angle) produces front-to-back motion (-1 to 1 range), scale mapping (0.7-1.3) makes closer stars appear larger via CSS transform, opacity mapping (0.6-1.0) dims distant stars for atmospheric depth, transform combines translate(-50%, -50%) centering with dynamic scale(), smooth 16ms CSS transitions prevent frame stuttering, radiation therapy star excluded from orbit logic via id check - remains stationary as center point
**Friction:** None - elliptical orbit with depth-based scaling/opacity integrated cleanly with existing rendering
**Insight:** 3D orbital illusion in 2D requires three techniques working together: elliptical paths (Y-axis compression simulates perspective), scale variation (closer = bigger via z-depth mapping), and opacity variation (closer = more opaque for atmospheric depth). Z-depth calculated as Math.sin(angle) creates natural front-to-back oscillation where stars appear to come toward viewer then recede away. Mapping z-depth range (-1 to 1) to scale/opacity ranges via linear interpolation ((zDepth + 1) / 2) creates smooth transitions. Transform composition (translate for centering, scale for depth) keeps star anchored to orbit position while varying size. Ellipse ratio of 0.5 (half vertical movement) provides strong 3D perspective without extreme distortion. CSS transitions matching animation frame rate (16ms) smooth out discrete state updates. Scale range 0.7-1.3 (40% size variation) and opacity range 0.6-1.0 provide noticeable depth without excessive extremes.

---

## Entry #061
**Focus:** Spatial arrow key navigation for orbiting constellation stars
**Smooth:** Replaced fixed-order cycling navigation with real-time spatial navigation system, targets array built from current constellationStars positions plus telescope position (320, 520), direction vector determined from arrow key press (¬±1 for x/y), dot product alignment check (dx * directionX + dy * directionY) filters targets to only those in pressed direction, scoring algorithm (distance / alignment) finds nearest well-aligned target in that direction, constellationStars added to useEffect dependencies for real-time position updates
**Friction:** None - spatial navigation algorithm integrated cleanly with existing key handler
**Insight:** Spatial navigation for dynamic elements requires reading current positions rather than fixed lists - build targets array from live state (constellationStars.map). Dot product (vector projection) elegantly filters targets to those in the correct direction - positive alignment means target is in pressed direction, zero or negative means wrong direction. Scoring as distance/alignment balances two factors: prefer close targets (low distance) that are well-aligned (high alignment). This creates intuitive navigation where pressing right moves to the rightmost nearby star, not the closest star that happens to be slightly right. For orbiting elements, adding dependencies (constellationStars, showFinalConstellation) to useEffect ensures navigation logic always uses current positions. Spatial navigation feels more natural than list cycling for scattered elements - users expect arrow keys to move in screen-space directions.

---

## Entry #062
**Focus:** Star name labels with Aseprite font, tiny star orbital companion for HDR, and faster climbing speed
**Smooth:** StarNameLabel styled component uses Aseprite font (12px) with pure white color positioned 18px right and 7px above highlighted stars, starNames mapping provides clean lookup for all constellation star IDs, tiny-star.png (1x1 pixel) orbits HDR star with separate animations for sky view (5px radius) and modal view (50px radius scaled to 4px sprite), ref-based state access (constellationStarsRef) prevents interval recreation from rapidly updating constellation array, elliptical orbit (0.5 Y-axis compression) creates 3D depth effect, climb speed doubled from 2.0 to 4.0 pixels per frame matching walk speed with sprite animation also doubled (frame speed 4‚Üí2) for snappier vertical movement
**Friction:** Initial tiny star animation failed in sky view because constellationStars dependency caused interval to recreate every 16ms - solved by using ref pattern to read current positions without triggering effect recreation, orbit radius needed separate tuning for sky view (very tight 5px) vs modal view (visible 50px)
**Insight:** Text labels next to UI elements work best with minimal styling - plain white Aseprite font without backgrounds or glows maintains clean aesthetic while remaining readable. Orbital companions (tiny star around HDR) add visual interest and storytelling depth without requiring interaction - 1px sprites feel appropriate for distant/companion objects. Animation intervals that read frequently-updating state must use refs to avoid recreation - pattern: create stateRef, sync with useEffect, read ref.current in interval. Different viewing contexts (zoomed out sky vs close-up modal) require different orbital scales to maintain visual impact - tight 5px orbit in sky view becomes nearly invisible, so modal needs 10x radius (50px) for same perceived effect. Climbing mechanics benefit from matching walk speed rather than being artificially slower - 4.0 pixels/frame with faster sprite animation (2 ticks) feels responsive and reduces frustration in vertical traversal.

---

## Entry #063
**Focus:** Constellation star count reduction and telescope scroll-home fix
**Smooth:** Reduced constellation from 10 stars to 4 (radiation_therapy center, hdr, imrt, tbi satellites) creating cleaner visual grouping, telescope X key handler bug fixed by adding `skyHighlight !== 'telescope'` condition to Priority 3 preventing else-if chain blocking
**Friction:** Priority chain bug was subtle - Priority 3 checked `currentView === 'sky' && !showStarDetail` then nested constellation star check inside, so telescope highlight entered block but failed inner check and prevented Priority 5 from executing
**Insight:** Else-if chains with nested conditionals can create blocking behavior - when outer condition matches but inner logic fails, subsequent else-if blocks never execute. Solution is to include discriminating conditions (like `!== 'telescope'`) in the outer else-if clause to prevent entering the block at all. Simpler is better for constellation complexity - 3 satellite stars orbiting center creates recognizable cluster without visual overload.

---

## Entry #064
**Focus:** Added third debug state "After Cutscene" to debug grid with expanded sprite sheet, plus constellation navigation fix and second activity TBI conversion
**Smooth:** Updated debug-icons.png sprite sheet from 112x53 (2 frames) to 168x53 (3 frames at 56x53 each), background-size calculation updated from 200% to 300%, background-position now uses ternary chain (0% / 50% / 100%) for three frame support, third debug box added to grid with frame 2 showing "After Cutscene" label, new localStorage flag 'debug_after_cutscene' with handler in CombinedHomeScene that positions Kapoor at desk, marks both hasCompletedFirstActivity and hasSeenConstellationCutscene as true, shows final constellation, and enables desk X key for immediate second activity access, second activity successfully converted from HDR to TBI with two TBI-focused questions ("primary purpose of TBI" and "major concern with dose uniformity")
**Friction:** Initial implementation forgot to create constellation stars array (only set showFinalConstellation flag), missed deskXKeyEnabled flag, positioned Kapoor too far from desk (x:200 vs desk at x:400, outside 60px proximity threshold), skyHighlight defaulted to 'star' (??? star) causing constellation stars to be unselectable - fixed by setting skyHighlight to 'tbi' in debug state initialization
**Insight:** Debug state systems scale cleanly when sprite sheet patterns are properly abstracted - adding new frames just requires updating frame count math (n frames = n√ó100% background-size, position = frameIndex √ó 100/(n-1)%). Post-cutscene debug state enables testing second activity flow without playing through entire progression. Setting both activity completion AND cutscene completion flags ensures all prerequisite state is properly initialized. When skipping animations, must manually create the data structures that animations would have populated (constellation stars array with final frames 8/10). Proximity-based UI elements need character positioned within threshold distance - calculate beforehand (desk at x:400, threshold 60px, so Kapoor needs x>340 and x<460). Let proximity checks handle visibility flags naturally rather than forcing them in debug setup. skyHighlight state determines which constellation element is selectable - when showing full constellation, must set to valid constellation star ID (not default 'star' which refers to ??? tutorial star). Activity content pivots (HDR‚ÜíTBI) only require updating question data and cycling text target - animation/UI systems remain generic.

---

## Entry #065
**Focus:** Planet-and-moons constellation system - transformed star constellation into TBI planet with orbiting moon subtopics
**Smooth:** Complete constellation redesign from stars to planetary system, TBI planet as center body with three orbiting moons (TBI Dosimetry, TBI Prescriptions, TBI Commissioning), all constellation infrastructure seamlessly adapted (orbital animation, cutscene reveal, spatial navigation, modal display), removed tiny star orbital companion (previously orbited HDR), type system updates cascaded cleanly through StarIdType and SkyHighlightType, modal data updated with descriptive content for each moon subtopic, debug state initialization updated to use new IDs, frame logic maintained (moons use frame 8, planet uses frame 10)
**Friction:** TypeScript linting initially confused by type changes across component boundaries - resolved by explicitly typing starDataMap with Record<NonNullable<StarDetailModalProps['starId']>, ...> to ensure type inference worked correctly, tiny star cleanup required removing state, animation loop, and rendering in both CombinedHomeScene and StarDetailModal, multiple references to old constellation IDs (radiation_therapy, hdr, imrt) needed systematic replacement throughout codebase
**Insight:** Planet-and-moons metaphor better represents topic relationships than flat star constellation - main topic at center with subtopics orbiting around it. When refactoring type systems across component boundaries, explicit type annotations on data structures (Record<> pattern) ensure TypeScript understands relationships even during transition periods. Systematic find-replace of IDs requires checking: type definitions, state initialization, cutscene setup, debug states, modal data, frame calculations, and X key handlers. Removing deprecated features (tiny star) means cleaning up state declarations, animation loops, and all rendering logic in both parent and modal components. Orbital animation systems compose cleanly with scale and opacity modulation.

---

## Entry #066
**Focus:** TBI planet modal enhancement with orbiting moons visualization and dynamic z-index layering
**Smooth:** Removed 2.5x scale multiplier from TBI planet in sky view for consistent sizing, added 3 orbiting moons to TBI planet modal using MoonSprite component (repurposed from TinyStar), moons initialized at 120-degree offsets (0¬∞, 120¬∞, 240¬∞) for even spacing, tightened orbital radius to 60% of original distance (20px sky / 40px modal) creating more compact planetary system, moons scale (0.7-1.3) and fade (0.6-1.0 opacity) based on z-depth using sine wave calculation, moons rendered at 2x sprite scale (28px) to match planet's modal scale, dynamic z-index system: moons behind planet (zDepth < 0) render at z-index 149/199, planet at 150/200, moons in front (zDepth ‚â• 0) at 151/201 creating realistic orbital depth with proper occlusion, animation runs at 60fps with smooth transitions, modal-only feature (only appears when viewing TBI planet, not other moons), synchronized orbit speed (0.008 radians/frame) and radius (20px sky / 40px modal) between sky view and modal for consistent motion
**Friction:** Initial implementation rendered moons at 1x scale (14px) while planet used 4x scale (56px) causing size mismatch - corrected to uniform 2x scale (28px) and adjusted orbit radius, needed to add zIndex to TypeScript types and apply dynamically based on z-depth calculation, initial modal orbit was faster (0.015) and larger (54px) than sky view - synchronized to match, adjusted radius to account for 2x sprite scaling (20px ‚Üí 40px)
**Insight:** Modal views can show richer detail than zoomed-out views - displaying orbital relationships in modal provides educational context while keeping sky view clean. Tighter orbits (60% of original distance) create more focused, intimate planetary systems that read better at both scales. Dynamic z-index based on orbital position creates realistic depth - moons naturally pass behind and in front of planet as they orbit. Math.sin(angle) provides perfect z-depth calculation: negative = behind, positive = in front. Z-index layering strategy: behind (n-1), center planet (n), in front (n+1) ensures proper occlusion. Orbital parameters (speed and radius) should match between different views of the same system for consistent player perception - synchronized motion creates coherent world physics. When reusing sprite sheets at different contexts (sky 1x vs modal 2x), all related measurements must scale uniformly (2x) while allowing for compositional adjustments (orbit tightening).

---

## Entry #067
**Focus:** Dynamic orbital navigation system with camera translation - arrow key navigation between planet and moons
**Smooth:** Replaced fixed star modal with dynamic focus system using absolute coordinate system, all 4 bodies (TBI planet + 3 moons) maintain their absolute positions continuously with TBI planet at origin (0, 0) and moons orbiting around it, camera translation system calculates relative positions by subtracting focused body's position from all bodies (relativeX = absoluteX - focusedX), arrow key spatial navigation uses dot product alignment to find nearest body in pressed direction (alignment threshold 0.3 allows slightly off-axis targets), modal content dynamically updates based on focused body (name, description, topic all swap when navigating), smooth 0.5s ease-out transitions on all properties (left/top/transform/opacity) create fluid camera panning when focus changes, fixed position:relative vs position:absolute mismatch by adding inline position:absolute override to focused StarSprite, unified component rendering by using MoonSprite for all bodies maintaining component identity during focus transitions - prevents React unmount/remount that breaks CSS transitions, focused body always renders at scale 1.0 and opacity 1.0 while others use dynamic scale/opacity based on z-depth, frame logic adapts to body type (TBI planet frame 10, moons frame 8) for all positions
**Friction:** Initial implementation reinitializing bodies at evenly-spaced angles broke spatial coherence - refactored to absolute coordinate system with camera translation, StarSprite using position:relative while MoonSprite used position:absolute caused focused body offset - fixed with inline position override, switching between StarSprite and MoonSprite components caused instant teleporting when focus changed - React was unmounting/remounting components breaking CSS transitions, solved by using MoonSprite consistently for all bodies so React maintains component identity across focus changes
**Insight:** Camera translation preserves spatial relationships better than reinitialization - bodies maintain their true absolute positions and we just shift the viewport. Absolute coordinate system (planet at origin, moons orbit in world space) separates physics simulation from rendering concerns. Component consistency is critical for smooth CSS transitions - when React components change type (StarSprite ‚Üî MoonSprite), React unmounts/remounts them which resets all CSS transition state causing instant jumps instead of smooth animations. Solution: use same component type for all bodies regardless of focus state, only change inline style props. Position property mismatches (relative vs absolute) cause coordinate system conflicts - ensure all positioned elements in same system use same position mode (absolute for camera translation systems). Smooth 0.5s transitions on all animatable properties (left, top, transform, opacity) create cohesive camera panning where bodies gracefully slide to new positions and smoothly scale/fade when becoming focused. Focused body should always render at base scale/opacity (1.0) regardless of its z-depth in the orbital system - prevents jarring size changes when switching focus. Spatial navigation in absolute coordinates requires finding both current and target body positions, calculating delta vector, then scoring by distance/alignment ratio.

---

## Entry #068
**Focus:** Complete gameplay loop restoration - fixed post-cutscene sky highlight and desk interaction reset
**Smooth:** Sky view now correctly defaults to TBI planet (skyHighlight: 'tbi') after cutscene completion instead of ??? star, conditional logic checks hasSeenConstellationCutscene flag when entering sky view to determine appropriate highlight target (pre-cutscene: 'star', post-cutscene: 'tbi'), desk X key state reset in handleCloseAbilityInterface allows repeated desk interactions, removed conflicting code that was resetting skyHighlight back to 'star' after cutscene transitions
**Friction:** Initial bug had skyHighlight defaulting to 'star' (??? tutorial star) after returning from activities post-cutscene, causing X key to appear on wrong star and opening wrong modal while TBI planet/moons rendered but weren't selectable, deskXKeyTriggered flag was never being reset so desk became non-interactive after first use breaking the core loop, multiple places in code were setting skyHighlight without checking cutscene completion status
**Insight:** Gameplay loops require careful state reset management - interaction flags (xKeyTriggered, deskXKeyTriggered) must reset when their contexts close to enable repeated interactions. Cutscene completion state should gate default UI focus - post-cutscene navigation should default to newly revealed content (TBI planet) rather than original tutorial elements (??? star). When debugging "UI not appearing" issues, check both visibility conditions AND whether prerequisite state flags have been properly reset. Multi-phase progression systems (pre-cutscene vs post-cutscene) need conditional logic throughout to provide appropriate defaults for each phase. Complete gameplay loop flow: (1) Sky ‚Üí navigate to planet/moons ‚Üí view modal (enables desk), (2) Sky ‚Üí telescope ‚Üí home, (3) Home ‚Üí walk to desk ‚Üí press X ‚Üí activity, (4) Activity complete ‚Üí desk X key resets ‚Üí repeat from step 1.

---

## Entry #069
**Focus:** Comp-sheet desk interaction overhaul - removed journal/book popup, integrated quiz directly on comp-sheet frame 1
**Smooth:** New 9-frame comp-sheet sprite system (600√ó360 per frame, 5400px total width) integrates cleanly with desk X key proximity system, phase-based animation state machine (idle ‚Üí waiting ‚Üí transitioning ‚Üí activity) provides clear progression, frames 2-7 loop creates waiting animation (200ms per frame), frames 8 ‚Üí 9 ‚Üí 1 sequence transitions to activity landing state, quiz overlay system renders directly on top of comp-sheet at frame 1 using absolute positioning (z-index 301), TBI quiz questions (2 questions about purpose and dose uniformity) embedded directly in CombinedHomeScene state, quiz interaction uses click-to-select with auto-advance after 2 seconds, results screen shows score and "Press X to continue" prompt, X key handler priority system includes quiz completion (Priority 0) before other interactions, comp-sheet stays visible throughout entire quiz flow maintaining visual continuity
**Friction:** Initial implementation attempted to open AbilityCardInterface which created messy dual-interface situation with book popup, needed complete refactor to keep everything on comp-sheet, styled components for quiz UI (QuizOverlay, QuizQuestion, QuizOptions, QuizOption, QuizResults) required careful z-index coordination to render above comp-sheet sprite, quiz state management (currentQuestionIndex, selectedOption, userAnswers, showResults) needed clean integration with existing desk interaction state machine
**Insight:** Modal interfaces work better when contained within a single visual context rather than spawning separate popups - keeping quiz on comp-sheet maintains spatial coherence. Multi-frame sprite animations benefit from phase-based state machines with explicit transitions between idle/waiting/transitioning/activity states. Quiz systems need three core states: question display (with option selection), answer confirmation (brief pause showing selection), and results screen (with exit prompt). Auto-advance timing (2 seconds) should be long enough to register selection but short enough to maintain momentum. Z-index layering for overlay content: base sprite (300) ‚Üí overlay UI (301) ‚Üí interactive elements inherit from overlay. Activity completion should trigger prerequisite flags (hasCompletedFirstActivity) for downstream features (constellation cutscene). State reset on exit must include all quiz variables (question index, selections, answers array) plus animation states (phase, frame) and interaction flags (deskXKeyTriggered). Comp-sheet frame 1 as "idle/activity" state creates natural landing point - animation completes on frame 1, then activity begins on same frame.

---

## Entry #070
**Focus:** Window-9slice container system for quiz UI with ExpandableAnswerContainer option buttons
**Smooth:** Created new 240√ó80px window-9slice.png sprite integrated cleanly into PixelContainer variant system (slice: '20 40 20 40 fill', borders: 20px vertical / 40px horizontal), WindowContainer component with expandable 9-slice rendering, quiz questions wrapped in WindowContainer (500px width) with transparent background to show comp-sheet underneath, answer options use existing ExpandableAnswerContainer with answer-9slice.png creating auto-sizing buttons that shrink to fit content width, 'fill' keyword in 9-slice config fills center area from sprite preventing hollow containers, conditional background removal for window variant (background-image: none when $variant === 'window') allows clean transparency, align-items: flex-start + width: fit-content on answer containers creates left-aligned auto-width layout instead of full-width stretch, color refinements (question text: #10141f dark blue-black, answer text: #62291a brown, selected: #FFD700 gold) provide readable hierarchy against filled 9-slice backgrounds
**Friction:** Initial implementation had opaque question-bg.png obscuring window-9slice - solved by conditionally disabling background-image for window variant, answer containers initially stretched full width - fixed with flex alignment and fit-content width, 9-slice centers were hollow (no fill keyword) showing transparency instead of sprite center - added 'fill' to both window and answer slice configs, previous text colors (white/gray) didn't provide enough contrast against filled backgrounds - iterated to darker colors
**Insight:** 9-slice containers need 'fill' keyword to render center portion from sprite - without it only borders appear creating hollow effect. Different variants can conditionally skip background layer (window uses transparent borders only) while others use filled backgrounds (answer uses opaque fill). Auto-sizing containers require three coordinated styles: parent flex container with align-items: flex-start, child containers with width: fit-content, and content elements without width: 100%. Color choices must account for background fill - light text works on dark/transparent backgrounds but dark text needed for light-filled 9-slices. Window-9slice at 240√ó80px provides good balance - 20px vertical borders feel substantial without being chunky, 40px horizontal borders accommodate longer text. PixelContainer variant system scales cleanly - adding new variants just requires asset paths, slice config, and optional conditional logic for special cases like transparent backgrounds.

---

## Entry #071
**Focus:** Multi-frame answer button with 9-slice expansion, hover/selected states, and instant frame switching
**Smooth:** Split answer sprite sheet (180x35) into 3 separate 60x35 images (answer-default.png, answer-hover.png, answer-selected.png) enabling proper 9-slice for each frame, created SpriteButtonContainer + SpriteFrameLayer components with 3 overlapping layers that toggle visibility via display: none/block (instant switching with no transitions), each layer uses border-image-slice: 10 10 10 10 fill for elegant 9-slice expansion - corners stay fixed, edges stretch, center fills, frame calculation logic (0 = default, 1 = hover, 2 = selected) cleanly maps states, internal hover state tracking with useState eliminates manual hover management in parent components, text positioning uses normal height for frames 0-1 and translateY(+2px) for frame 2 creating subtle button press effect, SpriteButtonContent with z-index: 2 ensures text renders above all frame layers
**Friction:** Initial attempts using sprite sheet (180x35 with 3 frames) failed completely - border-image cannot slice subsections of an image, it always uses entire image as 9-slice source causing all 3 frames to show simultaneously with sliding artifacts, conditional CSS styling within ExpandableContainer had zero effect due to 9-slice system conflicts, background-position approaches failed because container width expanding to fit text showed multiple frames regardless of positioning or overflow settings, debugging revealed sprite button code was executing but CSS wasn't working correctly, ultimately required splitting sprite sheet into 3 separate files to enable proper 9-slice per frame
**Insight:** Border-image 9-slice and sprite sheets are fundamentally incompatible - border-image always uses the entire source image and cannot be told to use "only pixels 60-120" from a sprite sheet. Solution requires either separate image files OR accepting simple stretching instead of 9-slice. Multi-layer approach with visibility toggling (display: none/block instead of opacity) provides instant frame switching with no transition artifacts. Each frame needs its own border-image layer to support proper 9-slice expansion. When debugging sprite-based UI and seeing sliding/multiple frames simultaneously, first check if 9-slice is trying to slice the entire sprite sheet. Container expansion for text content works cleanly when background layers use absolute positioning with width: 100% - they automatically stretch to match container size. Text drop effect (translateY +2px on selection) creates tactile feedback mimicking real button depression.

---

## Entry #072
**Focus:** Removed translateY transform from answer-selected state to prevent scrollbar
**Smooth:** Removed both instances of translateY(2px) transform from ExpandableContentWrapper and SpriteButtonContent styled components in PixelContainer.tsx, no linter errors after removal
**Friction:** Button press effect (translateY transform) was causing container overflow and scrollbar appearance when answer buttons were selected
**Insight:** Transform effects that move content outside original container bounds can trigger unwanted scrollbars - visual feedback effects like button press should be designed within the natural container dimensions. When debugging scrollbar issues, check for transforms (translateY, translateX, scale) on nested elements that might extend beyond parent containers. The overflow: hidden pattern (Entry #030, #040, #043) prevents some scrollbar issues but doesn't solve transform-induced overflow on parent containers.

---

## Entry #073
**Focus:** Uniform keyboard controls implementation across title screen, debug grid, and quiz system
**Smooth:** Title screen navigation with arrow keys (up/down) and X key activation worked cleanly with PIXI sprite texture/scale manipulation for highlighting, debug grid navigation with left/right arrows and Escape to close felt natural, quiz keyboard controls with arrow keys (up/down) and X key selection integrated seamlessly using event capture phase for priority handling, visual highlighting applied via isActive prop on ExpandableAnswerContainer, state management with highlightedQuizOption tracking and auto-reset on question changes, event.stopPropagation() and capture: true prevented keyboard conflicts between different systems
**Friction:** Multiple keyboard handlers across different contexts (title screen, debug grid, movement, quiz) required careful coordination of event.preventDefault() and priorities to avoid conflicts, quiz keyboard handler needed capture phase (capture: true) to intercept events before movement handlers
**Insight:** Uniform keyboard controls (arrow keys + X key) create consistent player experience across all game contexts - same mental model applies everywhere. Visual highlighting must match keyboard focus - players expect the highlighted element to respond to X key press. Event capture phase (addEventListener with {capture: true}) allows priority handlers to intercept events before they reach bubbling phase handlers. For quiz-like interactions, disable keyboard navigation after selection (selectedOption !== null check) prevents double-selection bugs. State reset patterns are critical - highlightedQuizOption must reset to 0 when currentQuestionIndex changes to maintain predictable navigation. Border highlighting with scale transform (border + scale(1.05)) provides clear visual feedback for keyboard-focused elements. Escape key as universal "go back" action feels intuitive for modal/overlay dismissal.

---

## Entry #074
**Focus:** Title screen 3-frame button sprite system with What's New integration and layout refinement
**Smooth:** Extended button sprite system from 2 frames to 3 frames (87x18 each = 261x18 total) creating distinct visual states (normal/highlighted/selected), all buttons (play-button.png, dev-mode-button.png, whats-new-button.png) use identical frame structure and animation patterns, converted What's New from HTML overlay button to PIXI sprite matching other buttons seamlessly, keyboard navigation extended to 3 buttons (arrow up/down cycles through Play ‚Üí Dev Mode ‚Üí What's New), visual highlighting effect resets all buttons to normal then highlights selected one preventing state conflicts, button repositioning (Play y=200, Dev Mode y=220, What's New y=240) created better vertical spacing and visual balance, PIXI texture system with normalTexture/highlightedTexture/selectedTexture storage enables instant frame switching without reload
**Friction:** Required updating button creation helper function signature and all three button instantiations, multiple references to old 2-frame system (hoverTexture renamed to highlightedTexture, added selectedTexture), What's New HTML button removal required cleaning up WhatsNewButton styled component references and showWhatsNew state usage, animation loop needed updates to fade in all three buttons synchronously
**Insight:** 3-frame button systems provide better visual feedback than 2-frame: normal (resting), highlighted (keyboard/hover), selected (clicked) creates clear interaction states. Converting HTML overlay buttons to PIXI sprites maintains visual consistency and allows unified animation control - all buttons fade/scale together during intro. When extending navigation systems (2 buttons ‚Üí 3 buttons), update both state bounds (Math.min(2, prev + 1)) and handler conditionals (if selectedButton === 2). Vertical spacing matters - 20px gaps between buttons improved composition. PIXI sprite texture swapping is instantaneous and clean - store all frame textures as properties on sprite object for easy access ((sprite as any).normalTexture pattern).

---

## Entry #075
**Focus:** Debug grid 3-frame sprite system with per-icon state visualization
**Smooth:** Extended debug-icons.png from 3 frames to 9 frames (56x53 each, 504x53 total) organizing as 3 sets of 3 frames (Before Desk 0-2, Before Cutscene 3-5, After Cutscene 6-8), each set has normal/highlighted/selected states, frame calculation uses baseFrame (debugOption * 3) + stateOffset (0 or 1) for clean state mapping, background-size 900% and position calculation (frame * 100 / 8) handles 9-frame layout correctly, $debugOption and $isSelected props passed to styled component enable dynamic frame selection, keyboard navigation shows highlighted frame (offset 1) when selected, normal frame (offset 0) otherwise
**Friction:** Background-position calculation requires dividing by (frameCount - 1) not frameCount - 9 frames means 8 gaps so position = frame * 100 / 8
**Insight:** Multi-state sprite sheets work best organized as groups: 3 icons √ó 3 states = 9 frames total. Frame calculation pattern (baseFrame + offset) scales cleanly for any number of items/states. Sprite sheet background-position math: for N frames, position percentage = (frameIndex * 100) / (N - 1) because there are N-1 gaps between frames. Separating $debugOption (which icon) from $isSelected (which state) creates clean prop interface and makes rendering logic explicit. Third frame (selected/pressed state) reserved for future mouse click feedback - currently using only normal and highlighted states for keyboard navigation.

---

## Entry #076
**Focus:** Expanded comp-sheet to 14-frame system with 5 selectable activities and idle animation
**Smooth:** Extended comp-sheet sprite from 9 to 14 frames (600x360 each = 8400px total width) with clear frame organization (1: blank, 2: activity window baseline, 3-7: individual activity highlights, 8: pressed state, 9-14: idle animation loop), activity selection state tracking (selectedActivity, hoveredActivity, highlightedActivity) integrated cleanly with existing comp-sheet phase system, keyboard navigation with arrow keys cycles through 5 activities (up/down sequential, left/right with wrapping), hover highlighting system uses mouse enter/leave events to set hoveredActivity state which automatically triggers frame changes via animation loop, idle animation (frames 9-14) plays continuously at 200ms per frame when no activity is hovered/highlighted creating natural "Kapoor thinking" loop, activity click regions positioned as invisible overlays (z-index 301) with DEBUG_CLICKBOXES flag for visual tuning, frame logic in animation loop checks hoveredActivity/highlightedActivity and displays appropriate highlight frame (3-7) or continues idle loop, transition animation shows frame 8 (pressed state) for 150ms before landing on frame 1 (blank window) for quiz, answer button frames shifted to 1-2-3 system (1: default, 2: highlighted, 3: selected) for consistency with comp-sheet numbering
**Friction:** Initial comp-sheet animation loop needed dependency updates to include hoveredActivity and highlightedActivity for proper reactive frame updates, keyboard event handler required adding comp-sheet phase check as first priority before sky view navigation to prevent conflicts, activity click region positioning required iterative adjustment based on actual sprite layout (placeholder values: top-left 50/50, top-right 450/50, bottom-left 50/210, bottom-middle 240/210, bottom-right 450/210), state reset on quiz completion needed to include all activity state variables (selectedActivity, hoveredActivity, highlightedActivity) to enable repeated desk interactions
**Insight:** Multi-activity selection systems benefit from three-layer state tracking: selection (committed choice), hover (mouse proximity), and highlight (keyboard focus) - this enables smooth transitions between mouse and keyboard navigation. Idle animations during waiting states (frames 9-14 loop) create living UI feel while providing clear visual feedback that system is ready for input. Conditional frame logic in animation intervals (check hover/highlight ‚Üí show specific frame OR continue loop) elegantly handles both interactive highlighting and background animation without separate animation systems. Activity click regions work best as invisible overlays with absolute positioning - debug visualization flag enables precise tuning without cluttering production code. Frame numbering starting at 1 instead of 0 creates more intuitive mental model for non-programmers (frame 1 = first frame in sprite sheet) and matches common sprite sheet conventions. When extending sprite systems (9‚Üí14 frames), update ALL frame calculations (background-size multiplier, background-position offset, loop boundaries) and document new frame purposes in comments. Answer button frame progression (default‚Üíhighlighted‚Üíselected using frames 1-2-3) creates consistent interaction pattern across all clickable elements in quiz system.

---

## Entry #077
**Focus:** Comp-sheet refactor from monolithic 14-frame sprite to modular 4-layer composite system
**Smooth:** Split comp-sheet.png into 4 separate aligned layers maintaining 600x360 dimensions - window (static base, z-index 300), activity (static content, 301), options (7-frame highlight sheet, 302), option1 (5-frame autonomous animation, 303) - creating clean separation of concerns, layer visibility controlled by phase state (window always visible, layers 2-4 hide during 'activity' phase for quiz), options layer frame mapping (1: none, 2-6: activities highlighted, 7: pressed) integrated seamlessly with existing hover/highlight logic, option1 autonomous animation lingers on frame 1 for 1 second then loops frames 2-5 at 300ms creating independent "thinking" effect, z-index hierarchy coordinated across all elements (layers 300-303, click regions 304, quiz overlay 305), transition animation shows options frame 7 (pressed) for 150ms before hiding activity layers, state management uses compOptionsFrame and compOption1Frame with separate animation refs for independent control, cleanup logic updated to include compOption1AnimationRef
**Friction:** Removed old compSheetFrame state and compSheetAnimationRef (no longer needed), updated initialization in desk X key handler and reset logic in handleQuizComplete to use new state variables
**Insight:** Composite layer systems with aligned sprites scale better than monolithic multi-frame sheets - each layer can be animated independently (options responds to hover, option1 runs autonomously) without complex frame coordination logic. Static layers (window, activity base) use simple visibility toggles while animated layers (options, option1) use frame state for dynamic content. Z-index hierarchy must be planned across entire interaction system: base layers ‚Üí animated layers ‚Üí interaction overlays ‚Üí content overlays. Autonomous animations (option1 linger+loop) work cleanly with separate useEffect + ref pattern - no dependencies on other animation state prevents interval recreation. Phase-based visibility (waiting vs activity) creates clean transitions where activity selection hides interactive layers but preserves base window for quiz context. When refactoring sprite systems, update all references systematically: styled components, state declarations, initialization, animation logic, transition handlers, cleanup, and reset logic.

---

## Entry #078
**Focus:** Spatial navigation for comp-sheet activity selection and looping option1 animation refinement
**Smooth:** Replaced sequential arrow key cycling with dot product spatial navigation matching constellation system pattern (Entry #061), activity positions defined at center of each click region (activity 0: 110,100 top-left through activity 4: 510,260 bottom-right), direction vectors calculated from arrow keys (-1/+1 for x/y axes), alignment calculated via dot product (dx * directionX + dy * directionY) normalized by distance, alignment threshold (>0.3) filters targets to only those in pressed direction, distance/(alignment¬≤) scoring heavily favors well-aligned targets creating intuitive navigation (activity 0 right‚Üí1, activity 0 down‚Üí2), option1 animation converted from one-time linger to proper loop including frame 1 with recursive setTimeout pattern - frame 1 lingers 1000ms every loop, frames 2-5 advance at 150ms each
**Friction:** Initial scoring (distance/alignment) preferred closer diagonal targets over farther direct targets - squaring alignment in denominator solved this by heavily rewarding perfect alignment (1.0 alignment¬≤ vs 0.76 alignment¬≤ creates significant scoring difference), initial animation used setInterval for frames 2-5 only - refactored to recursive setTimeout function that checks current frame and applies appropriate timing (1000ms for frame 1, 150ms for frames 2-5)
**Insight:** Spatial navigation feels more natural than sequential cycling for visually scattered UI elements - users expect pressing down to move to the element below, not just the next item in an arbitrary list. Dot product alignment elegantly determines if target is "in the right direction" - positive alignment means correct direction, negative means wrong direction. Squaring alignment in scoring formula (distance/alignment¬≤) creates strong preference for directly-aligned targets over diagonal shortcuts - alignment=1.0 (perfect) vs alignment=0.76 (diagonal) becomes 1x vs 0.58x weight, making perfect alignment nearly twice as favorable. Alignment threshold (0.3) allows slightly off-axis movement while preventing counterintuitive jumps. Pattern consistency across different navigation contexts (comp-sheet activities, constellation stars, orbital moons) creates uniform player experience and enables code reuse. Variable-speed looping animations work best with recursive setTimeout pattern - conditional logic inside animation function applies frame-specific timing, creates natural rhythm (pause on key frame, rapid advance through action frames). When switching from setInterval to setTimeout-based animations, update all cleanup calls from clearInterval to clearTimeout.

---

## Entry #079
**Focus:** Planetary systems debug state overhaul - localized orbital mechanics with parent-child relationships and atmospheric depth layering
**Smooth:** Refactored orbital animation system from single-center (PRIMAREUS_POSITION hardcoded) to parent-child architecture using parentId property, planetPositions Map lookup enables each moon to orbit its own parent planet dynamically, added parentId: string to constellationStars TypeScript interface and all moon creation helpers, TBI system updated to include parentId: 'tbi' on all moons, planetary systems debug state completely rewritten with 7 localized systems concentrated in upper-left quadrant (x: 80-280, y: 70-175), ALL planets guaranteed to have 3-4 moons orbiting (no solo planets), createMoon helper function calculates initial position using polar coordinates (angle + distance) from parent center, varied orbital distances (20-38px) create visual hierarchy and depth, system 5 features 4 moons as showcase centerpiece with largest orbit radius (38px), system 6 repositioned up from y:220 to y:175 for better clustering and features 4 moons in tight cardinal directions (22px), all moons now animate with 3D orbital effects (elliptical paths, scale/opacity/z-index based on depth), removed fixed ORBIT_RADIUS constant in favor of individual moon.distance property, spatial concentration creates dense "cluster" appearance perfect for showcasing multiple orbital systems simultaneously, updated z-index system to render ALL celestial bodies (planets/moons/tutorial star) UNDER cloud layers - planets at z-index 3, moons at z-index 2-3 (based on orbital depth), clouds remain at z-index 4-11 creating atmospheric depth effect where clouds drift in front of celestial bodies
**Friction:** Initial orbital system was tightly coupled to TBI system checking for star.id === 'tbi' to skip planet, refactored to generic parentId check (!body.parentId means it's a planet), needed to create planetPositions lookup Map before processing moons to handle any constellation topology, console.warn added for debugging when parentId references non-existent planet, repositioned all systems from spread across entire sky (120-520 x, 80-250 y) to concentrated upper-left quadrant for better visual grouping, z-index values needed updates in three places: orbital animation calculation (2-3), constellation rendering default fallback (2-3), and tutorial star style (3)
**Insight:** Parent-child relationships (parentId property) enable truly localized planetary systems where each planet is the orbital center for its moons - no shared global center needed. Map-based position lookup (planetPositions.get(parentId)) allows flexible system topology without hardcoded dependencies. Separating planet identification from orbital logic (planets lack parentId, moons require parentId + angle + distance) creates clean architectural boundary. Individual orbital distances (stored as moon.distance property) enable varied system scales and visual interest - tight 20px orbits vs sweeping 38px orbits. Spatial concentration in one screen quadrant creates dramatic "star cluster" effect - multiple systems visible simultaneously without spreading player attention across entire sky. Debug showcase states benefit from guaranteed consistency - EVERY planet having moons prevents confusing "why isn't that one moving?" moments. Polar coordinate initialization (angle + distance) provides consistent math model for both static placement and dynamic animation. Generic parent-child orbital system scales to any number of systems without code changes - adding 8th planetary system just requires data. Z-index layering creates atmospheric depth - rendering celestial bodies UNDER cloud layers (z-index 2-3 vs 4-11) makes clouds feel foreground/atmospheric while stars feel distant, dramatically improves visual hierarchy and immersion. When repositioning grouped elements, move all related items proportionally to maintain spatial relationships.

---

## Entry #080
**Focus:** Fixed z-index stacking context issue preventing celestial bodies from rendering below clouds
**Smooth:** Split ParallaxRenderer into three separate containers with distinct z-index levels (background z-2, clouds z-8, telescope z-10), created dedicated CelestialLayer container (z-6) for stars/planets/moons that syncs with scroll position, layer grouping system using $layerGroup prop ('background' | 'clouds' | 'telescope') provides clean architectural separation, moved celestial body rendering from ScrollingContent to CelestialLayer maintaining scroll synchronization, pointer-events: none on parallax containers allows click-through to interactive elements
**Friction:** Initial attempt to set single z-index on ParallaxContainer failed due to CSS stacking context isolation - all internal layer z-indices only matter relative to each other, first fix (ParallaxContainer z-15) covered entire game including Kapoor/foreground/UI making everything disappear, second attempt (CelestialLayer z-3) rendered below sky background layers so celestial bodies were invisible, hardcoded z-index: 200 in StarSprite styled component had to be removed to allow inline z-index styles to work, understanding required that separate containers are needed at each z-level to interleave external content between internal parallax layers
**Insight:** CSS stacking contexts are isolated containers - elements inside one container cannot render between layers of another container regardless of z-index values. To interleave content between parallax layers, you must split the parallax system into multiple containers positioned at appropriate z-index levels. Multi-container parallax architecture: background container (z-2) ‚Üí external celestial layer (z-6) ‚Üí cloud container (z-8) ‚Üí telescope container (z-10) ‚Üí foreground content (z-12). Removing hardcoded z-index from styled components enables dynamic inline z-index control via style prop. When debugging "nothing renders" issues after z-index changes, check if high-z container is creating full-screen overlay blocking all content below. Pointer-events: none on overlay containers is essential but doesn't solve visual occlusion - only proper z-index hierarchy does.

---

## Entry #081
**Focus:** Celestial body sprite rebalancing and hexagonal 2-3-2 arrangement refinement
**Smooth:** Sprite frame reassignment seamlessly shifted moon sprites to planets (frames 21,24,27,30,33,36,39) and small moon sprites to orbiting moons (frames 20,23,26,29,32,35,38), hexagonal positioning created clean 2-3-2 layout (top: 2 systems, middle: 3 systems with featured center, bottom: 2 systems) concentrated in upper left quadrant with natural asymmetry, orbital distances adjusted for tighter clustering (18-32px radius) matching smaller sprite scale, all 7 systems maintain 3 orbiting moons each for visual consistency
**Friction:** None - sprite frame logic already generic enough to support arbitrary frame assignment, positioning calculations transferred cleanly to new hexagonal arrangement
**Insight:** When rescaling sprite hierarchies (planet‚Üímoon, moon‚Üísmall moon), all dependent measurements must scale proportionally - orbital distances reduced from 22-38px to 18-32px to match smaller sprite sizes. Hexagonal arrangements create natural visual clustering with implied central focus - middle row's centered system (S4) becomes the featured element. Asymmetrical positioning within geometric constraints (2-3-2 pattern) adds organic feel while maintaining recognizable structure. Sprite frame reassignment works seamlessly when rendering logic uses frame numbers generically rather than assuming semantic meanings.

---

## Entry #082
**Focus:** Abyss parallax layer integration above cloud system
**Smooth:** Extended ParallaxContainer layer group system to include 'abyss' at z-index 9 (between clouds z-8 and telescope z-10), added abyss.png to layers array with drift animation speed and 0.7 parallax factor for prominent foreground movement, layer filtering and rendering logic accommodated new layer group with conditional rendering pattern matching telescope implementation
**Friction:** None - parallax architecture from Entry #080 designed for extensible layer groups, adding new layer required only type extension and render section insertion
**Insight:** Multi-container parallax architecture scales cleanly for new atmospheric layers - z-index hierarchy (background 2 ‚Üí celestial 6 ‚Üí clouds 8 ‚Üí abyss 9 ‚Üí telescope 10) allows precise depth control. Layer groups enable independent z-index contexts for interleaving external content (celestial bodies, character sprites, UI) between parallax layers. Drift animation with 0.7 parallax factor creates slower parallax than telescope (1.0) but faster than clouds (0.3-0.65) positioning abyss as foreground atmospheric element. Pattern consistency (abyssLayer find, conditional rendering, Layer component props) maintains code clarity across layer expansions.

---

## Entry #083
**Focus:** Planet-only arrow key navigation with dynamic z-index elevation for highlighted planetary systems
**Smooth:** Navigation filter cleanly restricts targets to planets only (bodies without parentId) - moons excluded from sky view navigation, spatial navigation algorithm unchanged (dot product alignment + distance scoring), dynamic z-index system in orbital animation checks skyHighlightRef.current to elevate highlighted planets to z-index 100 and their moons to 99-101 (based on orbital depth), non-highlighted systems remain at z-index 2-3 under clouds/abyss, inline style application of zIndex property in StarSprite rendering enables per-frame z-index updates, ref-based state access (skyHighlightRef) prevents interval recreation while maintaining current highlight state, TypeScript types extended (SkyHighlightType, StarIdType) to include planet_1 through planet_7, starNames mapping provides labels for all planets, debug_planetary_systems initialization sets skyHighlight to planet_1 for immediate navigation
**Friction:** Initial orbital animation didn't handle planet z-index updates (only moons) - added conditional logic to update planet zIndex when they lack orbital properties, needed to add inline zIndex style property to StarSprite rendering to enable dynamic z-index changes per frame, StarNameLabel also needed dynamic zIndex (planet zIndex + 1) to render above elevated planets, navigation broke initially because X key at telescope set skyHighlight to 'tbi'/'star' which don't exist in debug planetary systems - added validation to auto-correct to first planet when invalid ID detected, planet sprites were changing when highlighted due to +9 frame offset designed for TBI constellation (frames 5-10) being applied to debug planets (frames 20-40) causing planet_1 (frame 21) to display as planet_4 (frame 30) - fixed by only applying +9 offset to frames 5-10, z-index elevation wasn't working because CelestialLayer container has fixed z-index 6 creating stacking context where child z-index values are relative to container not page - fixed by making CelestialLayer z-index dynamic (6 normal, 11 when planet highlighted) elevating entire layer above clouds/abyss
**Insight:** Planet-only navigation in sky view keeps control simple while allowing detailed moon exploration in modal view - separating coarse navigation (planets) from fine navigation (moons) creates clear interaction hierarchy. Dynamic z-index based on highlight state enables dramatic visual effect where selected planetary system "pops out" above atmospheric layers (clouds/abyss at z-8/9) using z-index 99-101, creating clear focus without disruptive animations. Ref-based state reading (skyHighlightRef.current) in animation intervals enables reactive z-index updates without recreating 60fps intervals - critical performance pattern for frequently-changing highlight state. Planets without parentId property cleanly identify as navigation targets vs moons with parentId - simple boolean filter creates architectural distinction. CSS stacking contexts are critical consideration for z-index systems - child elements' z-index values are relative to their container's stacking context, not the page. When container has fixed z-index 6 and clouds are at z-index 8 in separate container, children at z-index 100 still render below clouds. Solution: make container z-index dynamic and elevate entire container (6‚Üí11) when any child needs elevation. Frame offset highlighting (+9) only works for specific frame ranges - TBI constellation uses frames 5-10 with highlighted versions at 14-19, but debug planets use frames 20-40 with no highlighted variants. Conditional frame logic (isTBIConstellation check) prevents frame offset from wrapping to wrong sprites. Navigation validation essential when state IDs may not exist in all game modes - auto-correction to first valid target prevents broken navigation without disrupting user flow.

---

## Entry #084
**Focus:** Z-index layering fixes for telescope, tutorial star breakthrough, and modal sprite visibility
**Smooth:** Telescope z-index elevated from 10 to 13 (above ScrollingContent's z-12) cleanly resolved rendering behind home-sky-combo, CelestialLayer elevation condition expanded to include tutorial star (skyHighlight === 'star') alongside planet highlighting using OR logic, modal column z-index layering (StarSection z-100, InfoSection z-50) established proper stacking order, conditional rendering in modal (StarSprite for ??? star, allBodies.map for TBI constellation) solved empty render issue
**Friction:** Initial telescope ParallaxContainer at z-10 was below ScrollingContent (z-12) causing visual occlusion, tutorial star (???) couldn't break through abyss layer (z-9) because CelestialLayer elevation only checked for planet highlighting (skyHighlight.startsWith('planet_')), modal sprites invisible due to DOM stacking order - InfoSection rendered after StarSection causing overlap, StarSprite component defined but never rendered for ??? star because allBodies array only populated for TBI constellation
**Insight:** Z-index hierarchies require coordination across multiple rendering contexts - parallax layers (2-13), scrolling content (12), and elevated celestial bodies (11) must all be planned together. When adding new layers to existing systems, audit all z-index values to prevent regressions. Dynamic z-index elevation pattern (CelestialLayer 6‚Üí11) works for any highlighted celestial body by expanding the condition check - simple OR logic (star || planets) enables multiple highlight contexts without complex state management. Modal column layouts need explicit z-index when absolute-positioned content (sprites) must render above sibling containers - DOM order alone insufficient. Conditional rendering based on constellation type (??? star vs TBI system) prevents empty renders when data structures differ between contexts - check for empty arrays before attempting .map() operations.

---

## Entry #085
**Focus:** Planetary sprite sheet migration from star-sheet.png to organized planetary-sheet.png with 96-frame system
**Smooth:** Dual sprite sheet system in StarSprite component cleanly separates tutorial star (star-sheet.png, 40 frames, 1-indexed) from planetary systems (planetary-sheet.png, 96 frames, 0-indexed), new sprite organization (8 sets √ó 3 types √ó 4 sections) provides logical frame structure: Section 0 (0-23) default, Section 1 (24-47) highlighted, Section 2 (48-71) modal, Section 3 (72-95) modal highlighted, debug planetary systems updated to use new frame numbers (system 1: planet=2, moons=0; system 2: planet=5, moons=3; etc.), highlighting logic extended with +24 offset for planetary systems (section 0‚Üí1) alongside existing +9 offset for TBI constellation, conditional background-position calculation handles both 0-indexed (planetary) and 1-indexed (star) frame navigation, $isPlanetarySystem prop cleanly discriminates between sprite sheet systems
**Friction:** Initial implementation used frame * -14 for all sprites breaking tutorial star which uses 1-indexed frames - fixed with conditional (isPlanetarySystem ? frame * -14 : (frame - 1) * -14), needed to recalculate all 7 planetary system frame assignments following new organization pattern
**Insight:** Dual sprite sheet systems work best with explicit prop discrimination ($isPlanetarySystem) enabling different rendering logic per sheet. 0-indexed vs 1-indexed frame systems require separate background-position calculations - conditional template literals in styled components handle this elegantly. Organized sprite sheets with consistent patterns (sets √ó types √ó sections) create predictable frame calculation formulas: frame = (section √ó 24) + (setIndex √ó 3) + typeIndex. Section-based highlighting (default in section 0, highlighted in section 1) uses simple addition (+24) making frame transitions predictable. When migrating sprite sheets, update ALL references: styled component (background-image, background-size, background-position), initialization code (frame assignments), highlighting logic (frame offsets), and rendering (props to identify sheet type).

---

## Entry #086
**Focus:** Fixed planetary highlighting bug and disabled parallax scrolling for static background layers
**Smooth:** Planet highlighting bug resolved by checking star ID instead of frame range - planets 2 and 3 (frames 5 and 8) were incorrectly using TBI constellation offset (+9) because frame range check (5-10) matched both systems, switched to ID-based detection (planet_*/moon_* vs tbi*) enabling proper +24 offset for planetary systems, parallax scrolling disabled for sky/stars/abyss by setting loopSpeed: undefined, purple-abyss.png added as composite layer on top of abyss (both static, same size, z-index 12-13), telescope z-index elevated from 13 to 14 to render above new purple-abyss layer
**Friction:** Initial frame range overlap (TBI frames 5-10 vs planetary frames 0-23) caused conditional to always choose TBI path for overlapping frames since isTBIConstellation checked first, attempted reordering checks but realized both systems use different sprite sheets making frame ranges meaningless for discrimination, solution required checking star.id patterns instead of frame ranges
**Insight:** When multiple systems share overlapping frame ranges but use different sprite sheets, frame-based discrimination fails - ID pattern matching (startsWith checks) provides robust system identification. Frame range overlaps are inevitable when migrating sprite systems - don't rely on frame numbers alone to distinguish between systems. Parallax layer scrolling controlled by loopSpeed prop - setting to undefined creates static layers while maintaining parallax scroll transform. Composite layers (purple-abyss on abyss) work cleanly with same parallaxFactor and sequential z-index values. Z-index cascades require updating all affected layers when inserting new layers mid-stack (telescope 13‚Üí14 after adding purple-abyss at 13).

---

## Entry #087
**Focus:** TBI constellation migration to planetary-sheet.png sprite system with composite non-blurry layers, ultra-tight orbits, and z-index elevation above abyss
**Smooth:** Complete sprite system migration from star-sheet.png to planetary-sheet.png for TBI constellation - planet uses frame 2, moons use frame 0 (small moon sprite) creating better size hierarchy, dual-layer composite rendering (blurry base + crisp overlay at +48 frame offset) applied to both sky view and modal view provides atmospheric glow with sharp details, moons made non-highlightable in sky view (only planet can be highlighted) while remaining navigable in modal, modal highlighting system uses +24 frame offset for focused body creating clear visual distinction, orbital radius progressively tightened (45px ‚Üí 28px ‚Üí 20px, 28px ‚Üí 18px ‚Üí 12px, 42px ‚Üí 26px ‚Üí 18px) creating ultra-compact constellation, z-index elevation fix added TBI IDs to CelestialLayer elevation check (skyHighlight === 'tbi' || skyHighlight.startsWith('tbi_')) elevating layer from z-index 6 to 15 above abyss/purple-abyss (12-13), highlighted constellation bodies elevated to z-index 100-102 (was 99-101) ensuring full system renders above all atmospheric layers
**Friction:** Initial z-index elevation only checked for 'star' and 'planet_*' causing TBI constellation to render behind abyss layers - required adding explicit 'tbi' and 'tbi_*' checks to elevation conditional, moon highlighting needed parentId-based filtering to prevent sky view selection, frame assignments required updates across cutscene animation, debug state initialization, modal rendering, and highlighting logic, composite layer implementation needed careful z-index coordination (+1 for crisp overlay) and pointerEvents: none to prevent interaction blocking
**Insight:** Sprite sheet section organization (0-23 default, 24-47 highlighted, 48-71 modal crisp) enables elegant composite rendering - blurry atmospheric base with crisp detail overlay creates depth without fighting, use frame +48 for crisp layer and apply highlighting only to base layer. Z-index elevation conditions must explicitly include all constellation ID patterns - implicit grouping assumptions fail when IDs follow different naming conventions (tbi* vs planet_*). Ultra-tight orbital radii (12-20px range) create cohesive planetary systems that read as single entities rather than scattered points. Moon size hierarchy (small moon frame 0 vs planet frame 2) provides clear visual distinction between primary body and satellites. Dual-layer rendering works identically in both contexts (sky view and modal) when sprite sheet sections are properly organized. Modal body highlighting (+24 offset) combined with base scale/opacity creates strong focal point without disrupting orbital animation. When debugging z-index occlusion, check both container elevation (CelestialLayer) and individual body z-index values - both must coordinate to break through atmospheric layers. Moons filtered from sky navigation via parentId check creates intuitive interaction model: coarse navigation (planets only) in sky, fine navigation (all bodies) in modal.

---

## Entry #088
**Focus:** Major version deployment following VERSION_MANAGEMENT.md best practices - v1.0.0 release on rescoped-rogue branch
**Smooth:** Pre-deployment checklist executed systematically (git status ‚Üí local build ‚Üí version bump ‚Üí push), rescoped-rogue branch already had 3 well-organized commits from previous work (core systems, assets, cleanup) creating clean foundation, npm run version:major automated package.json and versionManager.ts updates with proper changelog entry, local build passed cleanly with no compilation errors (Next.js 15.3.1, 5 static pages generated), git push created new remote branch with tracking configured automatically, 4 total commits followed logical grouping (core ‚Üí assets ‚Üí cleanup ‚Üí version) matching documentation guidance
**Friction:** Initial build attempt hit EPERM sandbox permission error requiring retry with 'all' permissions, branch name rescoped-rogue already existed locally (previously created) but was exactly where we wanted to be, version bump from 0.8.0 ‚Üí 1.0.0 marked complete educational rescope as major milestone
**Insight:** VERSION_MANAGEMENT.md systematic approach prevents deployment issues documented in Entry #211 - checking git status first reveals scope (91 files: 36 modified, 26 deleted, 30 new), building locally catches errors before deployment, organizing commits logically (core/assets/cleanup) creates reviewable history. Pre-existing organized commits indicate previous good practices - when returning to branch, verify commit state before assuming work needed. Major version bumps (v1.0.0) appropriate for complete scope pivots even if not "production ready" - dev suffix (-dev) communicates ongoing development while milestone number reflects architectural significance. Automated version scripts (npm run version:major) eliminate manual coordination errors between package.json and versionManager.ts. Branch naming should reflect actual scope (rescoped-rogue) rather than exploratory naming (action-game-pivot) - clarity in branch names aids team communication and PR review. GitHub PR link automatically provided after push enables immediate review workflow. Following deployment checklist step-by-step (even when tedious) catches issues that would cause production failures - skip steps at your own risk.

---

<!-- 
TEMPLATE FOR NEW ENTRIES:

## Entry #[NUMBER]
**Focus:** [Primary goal or feature being built/fixed]
**Smooth:** [What worked well, successful patterns used]
**Friction:** [Challenges encountered and their solutions]
**Insight:** [Key learning to carry forward]

GUIDELINES:
- Keep entries concise and actionable
- Focus on patterns and solutions, not detailed implementation
- Note architectural decisions that might affect future work
- Flag any discoveries that should migrate to core docs
- No dates, no time estimates, no complexity assessments
- Number entries sequentially regardless of gaps between sessions
-->

## ENTRIES TO MIGRATE TO CORE DOCS
*List insights that should be moved to permanent documentation*

- [ ] Day progression system pattern (Entry #015) ‚Üí PATTERNS.md
- [ ] Active ability system architecture (Entry #018) ‚Üí ARCHITECTURE.md  
- [ ] React hook placement rules (Entry #016) ‚Üí PATTERNS.md
- [ ] Canvas scaling with ability panels (Entry #015) ‚Üí ARCHITECTURE.md
- [ ] Dialogue ‚Üí Activity transition flow (Entry #017) ‚Üí PATTERNS.md
- [ ] Resource cost validation patterns (Entry #019) ‚Üí PATTERNS.md
- [ ] Pre-activity tutorial explanations (Entry #019) ‚Üí PATTERNS.md
- [ ] CSS-based UI elements over font-dependent text (Entry #021) ‚Üí PATTERNS.md
- [ ] Periodic state checking for cross-store synchronization (Entry #021) ‚Üí ARCHITECTURE.md
- [ ] Screen band navigation pattern (Entry #021) ‚Üí PATTERNS.md
- [ ] Hover tooltip overflow prevention (Entry #021) ‚Üí PATTERNS.md
- [ ] Dynamic transition duration prop pattern (Entry #035) ‚Üí PATTERNS.md
- [ ] Parallax element positioning without counter-adjustments (Entry #035) ‚Üí ARCHITECTURE.md
- [ ] Delayed view state changes for animation completion (Entry #035) ‚Üí PATTERNS.md
- [ ] View-gated movement systems (Entry #035) ‚Üí PATTERNS.md
- [ ] Keyboard-driven navigation with explicit state tracking (Entry #037) ‚Üí PATTERNS.md
- [ ] Priority-based input handling (Entry #037) ‚Üí PATTERNS.md
- [ ] Animation interval ref-based state access (Entry #037) ‚Üí PATTERNS.md
- [ ] Parallax sprite sheet integration (Entry #038) ‚Üí ARCHITECTURE.md
- [ ] ParallaxFactor values for scroll synchronization (Entry #038) ‚Üí ARCHITECTURE.md
- [ ] Frame conversion at component boundaries (Entry #039) ‚Üí PATTERNS.md
- [ ] 3D orbital illusion techniques (Entry #060) ‚Üí PATTERNS.md
- [ ] Polar coordinate animation systems (Entry #060) ‚Üí ARCHITECTURE.md
- [ ] Spatial navigation algorithm with dot product (Entry #061) ‚Üí PATTERNS.md
- [ ] Dynamic position-based navigation (Entry #061) ‚Üí ARCHITECTURE.md
- [ ] Version deployment checklist prevents production issues (Entry #088) ‚Üí VERSION_MANAGEMENT.md
- [ ] Pre-existing commit organization verification pattern (Entry #088) ‚Üí PATTERNS.md
- [ ] Branch naming for scope clarity (Entry #088) ‚Üí PATTERNS.md

## WHEN TO WIPE THIS LOG
- After ~20-30 entries
- When file becomes unwieldy
- During major version transitions
- After migrating key insights to core docs

## WHAT GETS PRESERVED
- Architectural decisions ‚Üí ARCHITECTURE.md
- Proven patterns ‚Üí PATTERNS.md
- Sprite specifications ‚Üí SPRITES.md
- Known bugs/issues ‚Üí STACK.md
- Workflow improvements ‚Üí HUB.md