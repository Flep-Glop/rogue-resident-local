Summary of Learnings from this Session:
Verify Component Rendering: Sometimes the most straightforward explanation is the right one. We confirmed MomentumCounter wasn't updating because it wasn't actually being rendered anywhere, despite being imported. Adding distinctive visual markers or console logs is crucial for verifying component lifecycles.
DOM Inspection is Key: When visual styles or classes aren't behaving as expected, the browser's DevTools (Elements panel) are indispensable for seeing what's actually being rendered and what styles are applied, often revealing discrepancies with the source code (like outdated class names or incorrect component rendering).
State Source Matters: We initially saw momentum dots updating based on one store (gameStore) while the logic intended to use another (resourceStore). Ensuring UI elements read from the same state source as the logic that updates them is vital. Replacing the hardcoded dots with the MomentumCounter (which uses resourceStore) fixed this.
Type Safety & Linting: Catching type mismatches (like comparing activeAction to strings not in its type) and identifying unexported types (ResourceState, GameState) early through linting prevents runtime errors and confusion. Even using any temporarily is better than letting implicit any cause issues.